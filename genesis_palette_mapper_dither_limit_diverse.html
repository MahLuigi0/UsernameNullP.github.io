<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Sega Genesis Palette Mapper — Diversity Option</title>
<style>
  body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; padding: 18px; }
  .row { display:flex; gap:18px; align-items:flex-start; }
  canvas { border:1px solid #ccc; image-rendering: pixelated; }
  .palette-grid { display:grid; grid-template-columns: repeat(32, 18px); gap:2px; }
  .swatch { width:18px; height:18px; border:1px solid rgba(0,0,0,0.08); }
  .colors-list { max-height: 320px; overflow:auto; width:420px; border:1px solid #eee; padding:8px; }
  .controls { display:flex; gap:12px; align-items:center; flex-wrap:wrap; margin-bottom:12px; }
  label { display:flex; gap:6px; align-items:center; }
  input[type="number"] { width:80px; padding:6px; }
  button { padding:8px 12px; border-radius:6px; border:1px solid #bbb; background: #fafafa; cursor:pointer; }
  .stats { margin-top:8px; font-family:monospace; }
  .highlight { outline:2px solid #333; }
</style>
</head>
<body>
<h2>Sega Genesis Palette Mapper — Diversity Option</h2>
<p>Upload a sprite. Options: dithering, limit how many palette colors the processed image can use, and prefer diverse chosen colors.</p>

<div class="controls">
  <input id="fileInput" type="file" accept="image/*" />
  <label> Dither:
    <select id="ditherSelect">
      <option value="none">None</option>
      <option value="ordered">Ordered (4x4 Bayer)</option>
      <option value="floyd">Floyd–Steinberg</option>
    </select>
  </label>

  <label>Limit colors:
    <input id="limitCheck" type="checkbox" />
  </label>
  <label>Max colors:
    <input id="maxColorsInput" type="number" min="2" max="512" value="32" />
  </label>

  <label> Prefer diverse colors:
    <input id="diverseCheck" type="checkbox" />
  </label>

  <button id="processBtn" disabled>Process / Remap</button>
  <button id="downloadBtn" disabled>Download Remapped Image</button>
</div>

<div class="stats" id="statsArea">
  Original unique colors: <span id="origCount">0</span> &nbsp; | &nbsp;
  Processed unique colors: <span id="procCount">0</span> &nbsp; | &nbsp;
  Palette colors allowed: <span id="allowedCount">512</span>
</div>

<div class="row" style="margin-top:12px;">
  <div>
    <h4>Original</h4>
    <canvas id="origCanvas"></canvas>
  </div>
  <div>
    <h4>Processed</h4>
    <canvas id="outCanvas"></canvas>
  </div>
  <div style="min-width:420px;">
    <h4>Colors found (top first)</h4>
    <div id="colorsList" class="colors-list"></div>
  </div>
</div>

<h4>512-color Genesis Palette (allowed will be highlighted)</h4>
<div id="paletteGrid" class="palette-grid"></div>

<script>
// Embedded palette (512 hex colors)
const PALETTE = [
  "#000000",
  "#000048",
  "#000090",
  "#0000d8",
  "#200000",
  "#200048",
  "#200090",
  "#2000d8",
  "#480000",
  "#480048",
  "#480090",
  "#4800d8",
  "#680000",
  "#680048",
  "#680090",
  "#6800d8",
  "#900000",
  "#900048",
  "#900090",
  "#9000d8",
  "#b00000",
  "#b00048",
  "#b00090",
  "#b000d8",
  "#d80000",
  "#d80048",
  "#d80090",
  "#d800d8",
  "#f80000",
  "#f80048",
  "#f80090",
  "#f800d8",
  "#002400",
  "#002448",
  "#002490",
  "#0024d8",
  "#202400",
  "#202448",
  "#202490",
  "#2024d8",
  "#482400",
  "#482448",
  "#482490",
  "#4824d8",
  "#682400",
  "#682448",
  "#682490",
  "#6824d8",
  "#902400",
  "#902448",
  "#902490",
  "#9024d8",
  "#b02400",
  "#b02448",
  "#b02490",
  "#b024d8",
  "#d82400",
  "#d82448",
  "#d82490",
  "#d824d8",
  "#f82400",
  "#f82448",
  "#f82490",
  "#f824d8",
  "#004800",
  "#004848",
  "#004890",
  "#0048d8",
  "#204800",
  "#204848",
  "#204890",
  "#2048d8",
  "#484800",
  "#484848",
  "#484890",
  "#4848d8",
  "#684800",
  "#684848",
  "#684890",
  "#6848d8",
  "#904800",
  "#904848",
  "#904890",
  "#9048d8",
  "#b04800",
  "#b04848",
  "#b04890",
  "#b048d8",
  "#d84800",
  "#d84848",
  "#d84890",
  "#d848d8",
  "#f84800",
  "#f84848",
  "#f84890",
  "#f848d8",
  "#006c00",
  "#006c48",
  "#006c90",
  "#006cd8",
  "#206c00",
  "#206c48",
  "#206c90",
  "#206cd8",
  "#486c00",
  "#486c48",
  "#486c90",
  "#486cd8",
  "#686c00",
  "#686c48",
  "#686c90",
  "#686cd8",
  "#906c00",
  "#906c48",
  "#906c90",
  "#906cd8",
  "#b06c00",
  "#b06c48",
  "#b06c90",
  "#b06cd8",
  "#d86c00",
  "#d86c48",
  "#d86c90",
  "#d86cd8",
  "#f86c00",
  "#f86c48",
  "#f86c90",
  "#f86cd8",
  "#009000",
  "#009048",
  "#009090",
  "#0090d8",
  "#209000",
  "#209048",
  "#209090",
  "#2090d8",
  "#489000",
  "#489048",
  "#489090",
  "#4890d8",
  "#689000",
  "#689048",
  "#689090",
  "#6890d8",
  "#909000",
  "#909048",
  "#909090",
  "#9090d8",
  "#b09000",
  "#b09048",
  "#b09090",
  "#b090d8",
  "#d89000",
  "#d89048",
  "#d89090",
  "#d890d8",
  "#f89000",
  "#f89048",
  "#f89090",
  "#f890d8",
  "#00b400",
  "#00b448",
  "#00b490",
  "#00b4d8",
  "#20b400",
  "#20b448",
  "#20b490",
  "#20b4d8",
  "#48b400",
  "#48b448",
  "#48b490",
  "#48b4d8",
  "#68b400",
  "#68b448",
  "#68b490",
  "#68b4d8",
  "#90b400",
  "#90b448",
  "#90b490",
  "#90b4d8",
  "#b0b400",
  "#b0b448",
  "#b0b490",
  "#b0b4d8",
  "#d8b400",
  "#d8b448",
  "#d8b490",
  "#d8b4d8",
  "#f8b400",
  "#f8b448",
  "#f8b490",
  "#f8b4d8",
  "#00d800",
  "#00d848",
  "#00d890",
  "#00d8d8",
  "#20d800",
  "#20d848",
  "#20d890",
  "#20d8d8",
  "#48d800",
  "#48d848",
  "#48d890",
  "#48d8d8",
  "#68d800",
  "#68d848",
  "#68d890",
  "#68d8d8",
  "#90d800",
  "#90d848",
  "#90d890",
  "#90d8d8",
  "#b0d800",
  "#b0d848",
  "#b0d890",
  "#b0d8d8",
  "#d8d800",
  "#d8d848",
  "#d8d890",
  "#d8d8d8",
  "#f8d800",
  "#f8d848",
  "#f8d890",
  "#f8d8d8",
  "#00fc00",
  "#00fc48",
  "#00fc90",
  "#00fcd8",
  "#20fc00",
  "#20fc48",
  "#20fc90",
  "#20fcd8",
  "#48fc00",
  "#48fc48",
  "#48fc90",
  "#48fcd8",
  "#68fc00",
  "#68fc48",
  "#68fc90",
  "#68fcd8",
  "#90fc00",
  "#90fc48",
  "#90fc90",
  "#90fcd8",
  "#b0fc00",
  "#b0fc48",
  "#b0fc90",
  "#b0fcd8",
  "#d8fc00",
  "#d8fc48",
  "#d8fc90",
  "#d8fcd8",
  "#f8fc00",
  "#f8fc48",
  "#f8fc90",
  "#f8fcd8",
  "#000020",
  "#000068",
  "#0000b0",
  "#0000f8",
  "#200020",
  "#200068",
  "#2000b0",
  "#2000f8",
  "#480020",
  "#480068",
  "#4800b0",
  "#4800f8",
  "#680020",
  "#680068",
  "#6800b0",
  "#6800f8",
  "#900020",
  "#900068",
  "#9000b0",
  "#9000f8",
  "#b00020",
  "#b00068",
  "#b000b0",
  "#b000f8",
  "#d80020",
  "#d80068",
  "#d800b0",
  "#d800f8",
  "#f80020",
  "#f80068",
  "#f800b0",
  "#f800f8",
  "#002420",
  "#002468",
  "#0024b0",
  "#0024f8",
  "#202420",
  "#202468",
  "#2024b0",
  "#2024f8",
  "#482420",
  "#482468",
  "#4824b0",
  "#4824f8",
  "#682420",
  "#682468",
  "#6824b0",
  "#6824f8",
  "#902420",
  "#902468",
  "#9024b0",
  "#9024f8",
  "#b02420",
  "#b02468",
  "#b024b0",
  "#b024f8",
  "#d82420",
  "#d82468",
  "#d824b0",
  "#d824f8",
  "#f82420",
  "#f82468",
  "#f824b0",
  "#f824f8",
  "#004820",
  "#004868",
  "#0048b0",
  "#0048f8",
  "#204820",
  "#204868",
  "#2048b0",
  "#2048f8",
  "#484820",
  "#484868",
  "#4848b0",
  "#4848f8",
  "#684820",
  "#684868",
  "#6848b0",
  "#6848f8",
  "#904820",
  "#904868",
  "#9048b0",
  "#9048f8",
  "#b04820",
  "#b04868",
  "#b048b0",
  "#b048f8",
  "#d84820",
  "#d84868",
  "#d848b0",
  "#d848f8",
  "#f84820",
  "#f84868",
  "#f848b0",
  "#f848f8",
  "#006c20",
  "#006c68",
  "#006cb0",
  "#006cf8",
  "#206c20",
  "#206c68",
  "#206cb0",
  "#206cf8",
  "#486c20",
  "#486c68",
  "#486cb0",
  "#486cf8",
  "#686c20",
  "#686c68",
  "#686cb0",
  "#686cf8",
  "#906c20",
  "#906c68",
  "#906cb0",
  "#906cf8",
  "#b06c20",
  "#b06c68",
  "#b06cb0",
  "#b06cf8",
  "#d86c20",
  "#d86c68",
  "#d86cb0",
  "#d86cf8",
  "#f86c20",
  "#f86c68",
  "#f86cb0",
  "#f86cf8",
  "#009020",
  "#009068",
  "#0090b0",
  "#0090f8",
  "#209020",
  "#209068",
  "#2090b0",
  "#2090f8",
  "#489020",
  "#489068",
  "#4890b0",
  "#4890f8",
  "#689020",
  "#689068",
  "#6890b0",
  "#6890f8",
  "#909020",
  "#909068",
  "#9090b0",
  "#9090f8",
  "#b09020",
  "#b09068",
  "#b090b0",
  "#b090f8",
  "#d89020",
  "#d89068",
  "#d890b0",
  "#d890f8",
  "#f89020",
  "#f89068",
  "#f890b0",
  "#f890f8",
  "#00b420",
  "#00b468",
  "#00b4b0",
  "#00b4f8",
  "#20b420",
  "#20b468",
  "#20b4b0",
  "#20b4f8",
  "#48b420",
  "#48b468",
  "#48b4b0",
  "#48b4f8",
  "#68b420",
  "#68b468",
  "#68b4b0",
  "#68b4f8",
  "#90b420",
  "#90b468",
  "#90b4b0",
  "#90b4f8",
  "#b0b420",
  "#b0b468",
  "#b0b4b0",
  "#b0b4f8",
  "#d8b420",
  "#d8b468",
  "#d8b4b0",
  "#d8b4f8",
  "#f8b420",
  "#f8b468",
  "#f8b4b0",
  "#f8b4f8",
  "#00d820",
  "#00d868",
  "#00d8b0",
  "#00d8f8",
  "#20d820",
  "#20d868",
  "#20d8b0",
  "#20d8f8",
  "#48d820",
  "#48d868",
  "#48d8b0",
  "#48d8f8",
  "#68d820",
  "#68d868",
  "#68d8b0",
  "#68d8f8",
  "#90d820",
  "#90d868",
  "#90d8b0",
  "#90d8f8",
  "#b0d820",
  "#b0d868",
  "#b0d8b0",
  "#b0d8f8",
  "#d8d820",
  "#d8d868",
  "#d8d8b0",
  "#d8d8f8",
  "#f8d820",
  "#f8d868",
  "#f8d8b0",
  "#f8d8f8",
  "#00fc20",
  "#00fc68",
  "#00fcb0",
  "#00fcf8",
  "#20fc20",
  "#20fc68",
  "#20fcb0",
  "#20fcf8",
  "#48fc20",
  "#48fc68",
  "#48fcb0",
  "#48fcf8",
  "#68fc20",
  "#68fc68",
  "#68fcb0",
  "#68fcf8",
  "#90fc20",
  "#90fc68",
  "#90fcb0",
  "#90fcf8",
  "#b0fc20",
  "#b0fc68",
  "#b0fcb0",
  "#b0fcf8",
  "#d8fc20",
  "#d8fc68",
  "#d8fcb0",
  "#d8fcf8",
  "#f8fc20",
  "#f8fc68",
  "#f8fcb0",
  "#f8fcf8"
];

function hexToRgb(hex) {
  const m = hex.replace('#','');
  return [parseInt(m.substring(0,2),16), parseInt(m.substring(2,4),16), parseInt(m.substring(4,6),16)];
}
const PALETTE_RGB = PALETTE.map(hexToRgb);

const fileInput = document.getElementById('fileInput');
const processBtn = document.getElementById('processBtn');
const downloadBtn = document.getElementById('downloadBtn');
const ditherSelect = document.getElementById('ditherSelect');
const limitCheck = document.getElementById('limitCheck');
const maxColorsInput = document.getElementById('maxColorsInput');
const diverseCheck = document.getElementById('diverseCheck');
const origCanvas = document.getElementById('origCanvas');
const outCanvas = document.getElementById('outCanvas');
const colorsListDiv = document.getElementById('colorsList');
const origCountSpan = document.getElementById('origCount');
const procCountSpan = document.getElementById('procCount');
const allowedCountSpan = document.getElementById('allowedCount');
const paletteGrid = document.getElementById('paletteGrid');

PALETTE.forEach(h => {
  const d = document.createElement('div');
  d.className = 'swatch';
  d.title = h;
  d.style.background = h;
  paletteGrid.appendChild(d);
});

let currentImage = null;
let currentImageName = 'sprite';
let latestMapping = null;

function colorKey(r,g,b) {
  return '#' + [r,g,b].map(x => x.toString(16).padStart(2,'0')).join('');
}

function findNearestInList(r,g,b, listRGB) {
  let bestIdx = 0;
  let bestDist = Infinity;
  for (let i=0;i<listRGB.length;i++) {
    const p = listRGB[i];
    const dr = p[0]-r, dg = p[1]-g, db = p[2]-b;
    const dist = dr*dr + dg*dg + db*db;
    if (dist < bestDist) {
      bestDist = dist; bestIdx = i;
    }
  }
  return bestIdx;
}

function buildHistogram(imgData) {
  const data = imgData.data;
  const counts = new Map();
  for (let i=0;i<data.length;i+=4) {
    const a = data[i+3];
    if (a === 0) continue;
    const r = data[i], g = data[i+1], b = data[i+2];
    const key = colorKey(r,g,b);
    counts.set(key, (counts.get(key)||0) + 1);
  }
  return counts;
}

// Choose allowed palette indices based on nearest mapping frequency, with optional diversity preference
function chooseAllowedPaletteIndices(countsMap, maxAllowed, preferDiverse) {
  const freqPerPaletteIdx = new Map();
  for (const [hex, cnt] of countsMap.entries()) {
    const rgb = hexToRgb(hex);
    const idx = findNearestInList(rgb[0], rgb[1], rgb[2], PALETTE_RGB);
    freqPerPaletteIdx.set(idx, (freqPerPaletteIdx.get(idx)||0)+cnt);
  }
  // Candidates: palette indices that appear in freq map (or all if empty)
  const candidates = Array.from(new Set(Array.from(freqPerPaletteIdx.keys())));
  if (candidates.length === 0) {
    // fallback: use all indices
    for (let i=0;i<PALETTE.length;i++) candidates.push(i);
  }
  // If user doesn't prefer diversity, just pick top by frequency
  if (!preferDiverse) {
    const sorted = Array.from(freqPerPaletteIdx.entries()).sort((a,b)=>b[1]-a[1]);
    const chosen = sorted.slice(0, maxAllowed).map(x=>x[0]);
    // fill if less than requested
    if (chosen.length < maxAllowed) {
      for (let i=0;i<PALETTE.length && chosen.length<maxAllowed;i++) {
        if (!chosen.includes(i)) chosen.push(i);
      }
    }
    return chosen;
  }

  // Prefer diverse selection: greedy maximize min-distance while considering frequency
  // Build arrays for candidates with frequency normalized
  const freqArr = {};
  let maxFreq = 0;
  for (const idx of candidates) {
    const f = freqPerPaletteIdx.get(idx) || 0;
    freqArr[idx] = f;
    if (f > maxFreq) maxFreq = f;
  }
  // normalize freq to 0..1
  const freqNorm = {};
  for (const idx of candidates) {
    freqNorm[idx] = maxFreq === 0 ? 0 : (freqArr[idx] / maxFreq);
  }

  // Precompute distances between palette colors (squared)
  const maxPossibleDist = 255*255*3; // 195075
  const distCache = {};
  for (let i=0;i<PALETTE_RGB.length;i++) {
    distCache[i] = {};
  }
  for (let i=0;i<PALETTE_RGB.length;i++) {
    for (let j=0;j<PALETTE_RGB.length;j++) {
      const a = PALETTE_RGB[i], b = PALETTE_RGB[j];
      const dr = a[0]-b[0], dg = a[1]-b[1], db = a[2]-b[2];
      distCache[i][j] = dr*dr + dg*dg + db*db;
    }
  }

  // Start selection
  const chosen = [];
  // pick initial seed: highest freq candidate
  candidates.sort((a,b)=> (freqArr[b] - freqArr[a]));
  chosen.push(candidates[0]);

  while (chosen.length < maxAllowed) {
    let bestIdx = null;
    let bestScore = -Infinity;
    for (const idx of candidates) {
      if (chosen.includes(idx)) continue;
      // compute min distance to chosen set
      let minDist = Infinity;
      for (const c of chosen) {
        const d = distCache[idx][c];
        if (d < minDist) minDist = d;
      }
      if (minDist === Infinity) minDist = 0;
      const distScore = minDist / maxPossibleDist; // 0..1
      const freqScore = freqNorm[idx] || 0;
      // combine: weight frequency higher but give diversity weight
      const score = 0.6*freqScore + 0.4*distScore;
      if (score > bestScore) {
        bestScore = score;
        bestIdx = idx;
      }
    }
    if (bestIdx === null) break;
    chosen.push(bestIdx);
    // if we've exhausted candidates, fill with remaining palette entries
    if (chosen.length === candidates.length) break;
  }

  // If still short, fill with other palette indices
  if (chosen.length < maxAllowed) {
    for (let i=0;i<PALETTE.length && chosen.length<maxAllowed;i++) {
      if (!chosen.includes(i)) chosen.push(i);
    }
  }

  return chosen.slice(0, maxAllowed);
}

// Dithering helpers (same as before)
const bayer4 = [
  [0, 8, 2,10],
  [12,4,14,6],
  [3,11,1,9],
  [15,7,13,5]
];

function applyOrderedDither(imgData, allowedIdxs) {
  const width = imgData.width, height = imgData.height;
  const data = imgData.data;
  const allowedRGB = allowedIdxs.map(i=>PALETTE_RGB[i]);
  for (let y=0;y<height;y++) {
    for (let x=0;x<width;x++) {
      const i = (y*width + x)*4;
      const a = data[i+3];
      if (a === 0) continue;
      const threshold = (bayer4[y%4][x%4] + 0.5)/16 - 0.5;
      let r = data[i], g = data[i+1], b = data[i+2];
      r = Math.max(0, Math.min(255, Math.round(r + threshold*16)));
      g = Math.max(0, Math.min(255, Math.round(g + threshold*16)));
      b = Math.max(0, Math.min(255, Math.round(b + threshold*16)));
      const idx = findNearestInList(r,g,b, allowedRGB);
      const pal = allowedRGB[idx];
      data[i] = pal[0]; data[i+1] = pal[1]; data[i+2] = pal[2];
    }
  }
  return imgData;
}

function applyFloydSteinberg(imgData, allowedIdxs) {
  const width = imgData.width, height = imgData.height;
  const data = imgData.data;
  const allowedRGB = allowedIdxs.map(i=>PALETTE_RGB[i]);
  const buf = new Float32Array(data.length);
  for (let i=0;i<data.length;i++) buf[i] = data[i];
  for (let y=0;y<height;y++) {
    for (let x=0;x<width;x++) {
      const idx = (y*width + x)*4;
      const a = buf[idx+3];
      if (a === 0) continue;
      const oldR = buf[idx], oldG = buf[idx+1], oldB = buf[idx+2];
      const nearestIdx = findNearestInList(oldR, oldG, oldB, allowedRGB);
      const pal = allowedRGB[nearestIdx];
      buf[idx] = pal[0]; buf[idx+1] = pal[1]; buf[idx+2] = pal[2];
      const errR = oldR - pal[0];
      const errG = oldG - pal[1];
      const errB = oldB - pal[2];
      if (x+1 < width) {
        let k = idx + 4;
        buf[k]   = buf[k]   + errR * 7/16;
        buf[k+1] = buf[k+1] + errG * 7/16;
        buf[k+2] = buf[k+2] + errB * 7/16;
      }
      if (x-1 >=0 && y+1 < height) {
        let k = idx + (width-1)*4;
        buf[k]   = buf[k]   + errR * 3/16;
        buf[k+1] = buf[k+1] + errG * 3/16;
        buf[k+2] = buf[k+2] + errB * 3/16;
      }
      if (y+1 < height) {
        let k = idx + width*4;
        buf[k]   = buf[k]   + errR * 5/16;
        buf[k+1] = buf[k+1] + errG * 5/16;
        buf[k+2] = buf[k+2] + errB * 5/16;
      }
      if (x+1 < width && y+1 < height) {
        let k = idx + (width+1)*4;
        buf[k]   = buf[k]   + errR * 1/16;
        buf[k+1] = buf[k+1] + errG * 1/16;
        buf[k+2] = buf[k+2] + errB * 1/16;
      }
    }
  }
  for (let i=0;i<data.length;i++) {
    if (i%4===3) data[i] = buf[i]; else data[i] = Math.max(0, Math.min(255, Math.round(buf[i])));
  }
  return imgData;
}

function mapWithoutDither(imgData, allowedIdxs) {
  const data = imgData.data;
  const allowedRGB = allowedIdxs.map(i=>PALETTE_RGB[i]);
  for (let i=0;i<data.length;i+=4) {
    const a = data[i+3];
    if (a === 0) continue;
    const r = data[i], g = data[i+1], b = data[i+2];
    const idx = findNearestInList(r,g,b, allowedRGB);
    const pal = allowedRGB[idx];
    data[i] = pal[0]; data[i+1] = pal[1]; data[i+2] = pal[2];
  }
  return imgData;
}

function countUniqueColors(imgData) {
  const data = imgData.data;
  const s = new Set();
  for (let i=0;i<data.length;i+=4) {
    const a = data[i+3];
    if (a === 0) continue;
    s.add(colorKey(data[i], data[i+1], data[i+2]));
  }
  return s.size;
}

function highlightAllowed(allowedIdxs) {
  Array.from(paletteGrid.children).forEach((el, i) => {
    el.classList.toggle('highlight', allowedIdxs.includes(i));
  });
}

function updateColorsList(countsMap, mappingToPalette) {
  colorsListDiv.innerHTML = '';
  const items = Array.from(countsMap.entries()).sort((a,b)=>b[1]-a[1]);
  const limitShow = 300;
  for (let i=0;i<Math.min(items.length, limitShow); i++) {
    const [hex, cnt] = items[i];
    const mapped = mappingToPalette.get(hex);
    const row = document.createElement('div');
    row.style.display='flex'; row.style.alignItems='center'; row.style.gap='8px'; row.style.marginBottom='6px';
    row.innerHTML = `
      <div style="width:24px;height:24px;border:1px solid #ccc;background:${hex}"></div>
      <div style="min-width:72px;font-family:monospace">${hex}</div>
      <div style="min-width:60px">x${cnt}</div>
      <div style="width:24px;height:24px;border:1px solid #ccc;background:${mapped.hex}"></div>
      <div style="font-family:monospace">${mapped.hex}</div>
      <div style="flex:1;text-align:right">palette idx: ${mapped.idx}</div>
    `;
    colorsListDiv.appendChild(row);
  }
  if (items.length > limitShow) {
    const more = document.createElement('div');
    more.textContent = `... and ${items.length - limitShow} more unique colors (not shown)`;
    colorsListDiv.appendChild(more);
  }
}

function processCurrentImage() {
  if (!currentImage) return;
  const img = currentImage;
  origCanvas.width = img.width; origCanvas.height = img.height;
  outCanvas.width = img.width; outCanvas.height = img.height;
  const octx = origCanvas.getContext('2d');
  const actx = outCanvas.getContext('2d');
  octx.clearRect(0,0,origCanvas.width, origCanvas.height);
  octx.drawImage(img,0,0);
  actx.clearRect(0,0,outCanvas.width, outCanvas.height);
  actx.drawImage(img,0,0);

  const imgData = octx.getImageData(0,0,origCanvas.width, origCanvas.height);
  const counts = buildHistogram(imgData);
  origCountSpan.textContent = counts.size;

  let allowedIdxs = [...Array(PALETTE.length).keys()];
  if (limitCheck.checked) {
    const maxC = Math.max(2, Math.min(512, parseInt(maxColorsInput.value) || 32));
    const preferDiverse = !!diverseCheck.checked;
    allowedIdxs = chooseAllowedPaletteIndices(counts, maxC, preferDiverse);
    allowedCountSpan.textContent = allowedIdxs.length;
  } else {
    allowedCountSpan.textContent = PALETTE.length;
  }
  highlightAllowed(allowedIdxs);

  const mappingToPalette = new Map();
  for (const [hex, cnt] of counts.entries()) {
    const rgb = hexToRgb(hex);
    const allowedRGB = allowedIdxs.map(i=>PALETTE_RGB[i]);
    const nearestRelIdx = findNearestInList(rgb[0], rgb[1], rgb[2], allowedRGB);
    const palIdx = allowedIdxs[nearestRelIdx];
    mappingToPalette.set(hex, { hex: PALETTE[palIdx], idx: palIdx });
  }

  let outImageData = octx.getImageData(0,0,origCanvas.width, origCanvas.height);
  const dither = ditherSelect.value;
  if (dither === 'none') {
    outImageData = mapWithoutDither(outImageData, allowedIdxs);
  } else if (dither === 'ordered') {
    outImageData = applyOrderedDither(outImageData, allowedIdxs);
  } else if (dither === 'floyd') {
    outImageData = applyFloydSteinberg(outImageData, allowedIdxs);
  }
  actx.putImageData(outImageData, 0, 0);

  const procUnique = countUniqueColors(outImageData);
  procCountSpan.textContent = procUnique;

  updateColorsList(counts, mappingToPalette);
  latestMapping = outImageData;
  downloadBtn.disabled = false;
}

fileInput.addEventListener('change', async (e) => {
  const file = e.target.files && e.target.files[0];
  if (!file) return;
  currentImageName = file.name.replace(/\.[^/.]+$/, "") || 'sprite';
  const img = new Image();
  img.src = URL.createObjectURL(file);
  await img.decode();
  currentImage = img;
  processBtn.disabled = false;
  processCurrentImage();
});

processBtn.addEventListener('click', () => {
  processCurrentImage();
});

downloadBtn.addEventListener('click', () => {
  if (!latestMapping) return;
  const link = document.createElement('a');
  link.download = currentImageName + '_genesis.png';
  const c = document.createElement('canvas');
  c.width = outCanvas.width; c.height = outCanvas.height;
  const cx = c.getContext('2d');
  cx.putImageData(latestMapping, 0, 0);
  link.href = c.toDataURL('image/png');
  link.click();
});

[ditherSelect, limitCheck, maxColorsInput, diverseCheck].forEach(el => {
  el.addEventListener('change', () => {
    if (!currentImage) return;
    processCurrentImage();
  });
});

</script>
</body>
</html>
