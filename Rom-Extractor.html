<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>ROM Extractor</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        select, input, button { margin: 10px 0; padding: 5px; }
        button { cursor: pointer; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</head>
<body>
    <h1>ROM Extractor</h1>
    <p>Upload the assets JSON file and a ROM file.</p>
    <label>Assets JSON File:</label><br>
    <input type="file" id="jsonFile" accept=".json"><br>
    <label>ROM File:</label><br>
    <input type="file" id="romFile" accept=".bin"><br>
    <select id="assetSelect" disabled>
        <option value="">Select an asset</option>
    </select><br>
    <button id="extractButton" disabled>Extract Selected</button>
    <button id="extractAllButton" disabled>Extract All to ZIP</button>
    <script>
        let assets = [];
        const jsonFileInput = document.getElementById('jsonFile');
        const romFileInput = document.getElementById('romFile');
        const assetSelect = document.getElementById('assetSelect');
        const extractButton = document.getElementById('extractButton');
        const extractAllButton = document.getElementById('extractAllButton');

        // Load JSON file and populate dropdown
        jsonFileInput.addEventListener('change', () => {
            if (jsonFileInput.files.length === 0) return;
            const file = jsonFileInput.files[0];
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    assets = JSON.parse(e.target.result);
                    // Clear existing options
                    assetSelect.innerHTML = '<option value="">Select an asset</option>';
                    // Group assets by category
                    const categories = [...new Set(assets.map(a => a.category))];
                    categories.forEach(category => {
                        const optgroup = document.createElement('optgroup');
                        optgroup.label = category;
                        assets.filter(a => a.category === category).forEach(asset => {
                            const option = document.createElement('option');
                            option.value = asset.name;
                            option.textContent = asset.name;
                            optgroup.appendChild(option);
                        });
                        assetSelect.appendChild(optgroup);
                    });
                    assetSelect.disabled = false;
                    checkButtons();
                } catch (err) {
                    alert('Error parsing JSON file: ' + err.message);
                }
            };
            reader.readAsText(file);
        });

        // Enable/disable buttons based on file inputs
        function checkButtons() {
            const hasJson = jsonFileInput.files.length > 0;
            const hasRom = romFileInput.files.length > 0;
            extractButton.disabled = !(hasJson && hasRom && assetSelect.value);
            extractAllButton.disabled = !(hasJson && hasRom);
        }

        romFileInput.addEventListener('change', checkButtons);
        assetSelect.addEventListener('change', checkButtons);

        // Extract single asset
        extractButton.addEventListener('click', () => {
            const selectedName = assetSelect.value;
            if (!selectedName) {
                alert('Please select an asset.');
                return;
            }
            const asset = assets.find(a => a.name === selectedName);
            const file = romFileInput.files[0];
            const reader = new FileReader();
            reader.onload = function(e) {
                const rom = e.target.result;
                const start = asset.start;
                const end = asset.end + 1; // End is inclusive
                if (end > rom.byteLength) {
                    alert('End offset exceeds ROM size for ' + asset.name);
                    return;
                }
                const extracted = rom.slice(start, end);
                const blob = new Blob([extracted], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${asset.name.replace(/ /g, '_')}.bin`;
                a.click();
                URL.revokeObjectURL(url);
            };
            reader.readAsArrayBuffer(file);
        });

        // Extract all assets to ZIP with category folders
        extractAllButton.addEventListener('click', () => {
            const file = romFileInput.files[0];
            const reader = new FileReader();
            reader.onload = function(e) {
                const rom = e.target.result;
                const zip = new JSZip();
                let hasError = false;
                assets.forEach(asset => {
                    const start = asset.start;
                    const end = asset.end + 1; // End is inclusive
                    if (end > rom.byteLength) {
                        console.warn(`End offset exceeds ROM size for ${asset.name}`);
                        hasError = true;
                        return;
                    }
                    const extracted = rom.slice(start, end);
                    // Create folder path using category, replacing spaces with underscores
                    const folder = asset.category.replace(/ /g, '_');
                    zip.file(`${folder}/${asset.name.replace(/ /g, '_')}.bin`, extracted);
                });
                if (hasError) {
                    alert('Some assets could not be extracted due to invalid offsets.');
                }
                zip.generateAsync({ type: 'blob' }).then(blob => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'Assets.zip';
                    a.click();
                    URL.revokeObjectURL(url);
                });
            };
            reader.readAsArrayBuffer(file);
        });
    </script>
</body>
</html>