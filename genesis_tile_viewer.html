<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Genesis Tile Viewer & Stamp Map Editor</title>
  <style>
    /* Page layout and typography */
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; padding: 18px; max-width: 1200px; margin: auto; }
    h1 { font-size: 1.2rem; margin-bottom: 10px; }
    label { display:block; margin: 10px 0; }

    /* Canvas styling */
    #canvas { border:1px solid #444; image-rendering: pixelated; display:block; margin-top:12px; max-width: 100%; cursor: crosshair; }
    #stampSelector { border:1px solid #444; cursor:pointer; max-width: 100%; image-rendering: pixelated; }

    /* Palette preview swatches */
    #palettePreview { margin-top: 10px; display: grid; grid-template-columns: repeat(16, 20px); /* 16 swatches per row */ grid-auto-rows: 20px; gap: 0; /* no gap between swatches */ width: fit-content; }
    .sw { width: 20px; height: 20px; display: block; margin: 0; border: none; box-sizing: border-box; }
    .sw.selected { outline: 2px solid #ff0; }

    /* Controls layout */
    .controls-container { display: flex; flex-wrap: wrap; gap: 20px; background-color: #f9f9f9; padding: 10px 20px; border-radius: 8px; margin-top: 10px;}
    .control-group { flex: 1; min-width: 250px; }
    .control-group h2 { font-size: 1rem; margin-top: 10px; margin-bottom: 5px; border-bottom: 1px solid #ddd; padding-bottom: 5px; }
    .btn { display:inline-block; margin-top:8px; padding:6px 10px; border-radius:6px; background:#1976d2; color:#fff; border:none; cursor:pointer; }
    .btn:active { transform: translateY(1px); }
    .btn-danger { background:#d32f2f; }
    .btn-success { background:#2e7d32; }

    /* Progress indicator */
    #progressBar { width: 100%; height: 20px; background: #e0e0e0; border-radius: 4px; margin-top: 10px; overflow: hidden; display: none; }
    #progressFill { height: 100%; background: #4CAF50; transition: width 0.2s; width: 0%; }
    #progressText { text-align: center; margin-top: 5px; color: #666; display: none; }

    /* Edit mode UI */
    #editTools { display: none; }
    #activeStampPreview { border:1px solid #444; image-rendering: pixelated; margin-top: 8px; }
    .edit-instruction { color: #1976d2; font-weight: bold; }

    /* Assembly modal */
    .modal-backdrop {
      position: fixed;
      left: 0; top: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.5);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }
    .modal {
      background: white;
      width: min(1100px, 95%);
      max-height: 90%;
      border-radius: 8px;
      padding: 12px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.3);
      display: flex;
      flex-direction: column;
    }
    #asmText {
      width: 100%;
      height: 60vh;
      font-family: monospace;
      font-size: 12px;
      white-space: pre;
      overflow: auto;
      margin-top: 8px;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 6px;
      resize: vertical;
    }
    .modal-actions { margin-top: 8px; display:flex; gap:8px; align-items:center; }
    .modal-actions .small { font-size: 0.9rem; color: #555; }
    .toggle { margin-left: 8px; }
  </style>
</head>
<body>
  <h1>Genesis Tile Viewer & Stamp Map Editor</h1>

  <div class="controls-container">
    <!-- Input Files -->
    <div class="control-group">
      <h2>Input Files</h2>
      <label>Tile file (.bin / .unc): <input id="fileTiles" type="file" accept=".bin,.unc"></label>
      <label>Palette file (.bin / .pal): <input id="filePalette" type="file" accept=".bin,.pal,.unc"></label>
      <label>Stamp map file (.bin / .unc): <input id="fileStampMap" type="file" accept=".bin,.unc"></label>
      <button id="btnExport" class="btn" title="Export current canvas to PNG">Export PNG</button>

      <!-- Palette preview and row selector -->
      <div id="palettePreview"></div>
      <label id="paletteRowContainer" style="display:none; margin-top:8px;">Palette Row: <select id="paletteRowSelect"></select></label>
    </div>

    <!-- Map Settings -->
    <div class="control-group">
      <h2>Stamp Map Settings</h2>
      <label>Map Size (in stamps):
        <select id="settingMapSize">
          <option value="16x16">16x16 stamps (256x256px)</option>
          <option value="8x8">8x8 stamps (256x256px)</option>
          <option value="256x256" selected="">256x256 stamps (4096x4096px)</option>
          <option value="128x128">128x128 stamps (4096x4096px)</option>
        </select>
      </label>
      <label>Stamp Size (in pixels):
        <select id="settingStampSize">
          <option value="16" selected="">16x16</option>
          <option value="32">32x32</option>
        </select>
      </label>
      <div class="hint">These settings are only used when a stamp map is loaded.</div>
    </div>

    <!-- Mode & Edit Tools -->
    <div class="control-group">
      <h2>Mode</h2>
      <label><input id="settingEditMode" type="checkbox"> Enable Edit Mode</label>
      <div class="hint">In edit mode, <span class="edit-instruction">click cells to place stamps</span> and <span class="edit-instruction">right-click to clear</span>.</div>
      
      <div id="editTools">
        <h2 style="margin-top: 15px;">Active Stamp</h2>
        <label>H-Flip: <input type="checkbox" id="editHFlip"></label>
        <label>Rotation: 
          <select id="editRotation">
            <option value="0" selected="">0°</option>
            <option value="1">90°</option>
            <option value="2">180°</option>
            <option value="3">270°</option>
          </select>
        </label>
        <canvas id="activeStampPreview" width="64" height="64"></canvas>
        <div id="activeStampInfo" style="margin-top: 5px; font-size: 0.85rem; color: #666;">Stamp 5 | H-Flip: false | Rotation: 0°</div>
        
        <h2 style="margin-top: 15px;">Stamp Palette</h2>
        <canvas id="stampSelector" width="512" height="32" style="display: block;"></canvas>
        <div style="margin-top:8px;">
          <button id="btnExportStampPalette" class="btn" title="Export the stamp palette as PNG (transparent background)">Export Stamp Palette PNG</button>
        </div>
        
        <div style="margin-top: 12px;">
          <button id="btnNewMap" class="btn">New Empty Map</button>
          <button id="btnClearMap" class="btn btn-danger">Clear Entire Map</button>
          <button id="btnSaveMap" class="btn btn-success">Save Map</button>
        </div>
      </div>
    </div>

    <!-- Assembly / Export -->
    <div class="control-group">
      <h2>Map Export</h2>
      <button id="btnView68k" class="btn" title="View the current stamp map as 68K words">View as 68K assembly</button>
      <div style="margin-top:8px;">
        <label><input id="optIncludeComments" type="checkbox" checked> Include row comments ( ; row N )</label>
        <label><input id="optLabelAtTop" type="checkbox"> Add label <code>stamp_map:</code> at top</label>
        <label style="display:inline-block; margin-left:8px;">Words per line: <input id="optWordsPerLine" type="number" value="0" min="0" style="width:70px; margin-left:6px;"> (0 = map width)</label>
      </div>
    </div>
  </div>

  <!-- Progress indicators -->
  <div id="progressBar" style="display: none;"><div id="progressFill" style="width: 100%;"></div></div>
  <div id="progressText" style="display: none;">Rendering: 65536 / 65536 stamps (100%)</div>

  <!-- Canvas where the tile grid or stamp map is drawn -->
  <canvas id="canvas" width="256" height="256" style="cursor: crosshair;"></canvas>

  <!-- Assembly modal -->
  <div id="asmModalBackdrop" class="modal-backdrop" role="dialog" aria-hidden="true">
    <div class="modal" role="document">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <strong>Stamp Map — 68K Assembly View</strong>
        <div>
          <button id="btnAsmCopy" class="btn">Copy</button>
          <button id="btnAsmDownload" class="btn btn-success">Download .asm</button>
          <button id="btnAsmClose" class="btn btn-danger">Close</button>
        </div>
      </div>

      <div class="modal-actions">
        <div style="flex:1"></div>
        <div class="small">Map source: <span id="asmMapSource">—</span></div>
      </div>

      <textarea id="asmText" readonly></textarea>
    </div>
  </div>

<script>
/* -------------------------
   DOM references & state
   ------------------------- */
const fileTiles = document.getElementById('fileTiles');
const filePalette = document.getElementById('filePalette');
const fileStampMap = document.getElementById('fileStampMap');
const settingMapSize = document.getElementById('settingMapSize');
const settingStampSize = document.getElementById('settingStampSize');
const settingEditMode = document.getElementById('settingEditMode');
const btnExport = document.getElementById('btnExport');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const palettePreview = document.getElementById('palettePreview');
const paletteRowContainer = document.getElementById('paletteRowContainer');
const paletteRowSelect = document.getElementById('paletteRowSelect');
const progressBar = document.getElementById('progressBar');
const progressFill = document.getElementById('progressFill');
const progressText = document.getElementById('progressText');

// Edit mode elements
const editTools = document.getElementById('editTools');
const editHFlip = document.getElementById('editHFlip');
const editRotation = document.getElementById('editRotation');
const activeStampPreview = document.getElementById('activeStampPreview');
const activeStampInfo = document.getElementById('activeStampInfo');
const stampSelector = document.getElementById('stampSelector');
const stampSelectorCtx = stampSelector.getContext('2d');
const btnNewMap = document.getElementById('btnNewMap');
const btnClearMap = document.getElementById('btnClearMap');
const btnSaveMap = document.getElementById('btnSaveMap');
const btnExportStampPalette = document.getElementById('btnExportStampPalette');

// Assembly UI
const btnView68k = document.getElementById('btnView68k');
const asmModalBackdrop = document.getElementById('asmModalBackdrop');
const asmText = document.getElementById('asmText');
const btnAsmClose = document.getElementById('btnAsmClose');
const btnAsmCopy = document.getElementById('btnAsmCopy');
const btnAsmDownload = document.getElementById('btnAsmDownload');
const optIncludeComments = document.getElementById('optIncludeComments');
const optLabelAtTop = document.getElementById('optLabelAtTop');
const optWordsPerLine = document.getElementById('optWordsPerLine');
const asmMapSource = document.getElementById('asmMapSource');

// State
let tileData = null;
let paletteData = null;
let stampMapData = null;
let editableStampMapData = null;
let stampMapFilename = null;
let renderingInProgress = false;
let cancelRendering = false;
let isEditMode = false;
let activeStampIndex = 1;
let activeHFlip = false;
let activeRotation = 0;
let paletteRow = 0; // <-- selected palette row (0-based)

function sanitizeLabel(name) {
  if (!name) return 'stamp_map';
  // strip extension
  const base = name.replace(/\.[^/.]+$/, '');
  // replace invalid characters with underscore
  return base.replace(/[^A-Za-z0-9_]/g, '_');
}

/* -------------------------
   File input handlers
   ------------------------- */
fileTiles.addEventListener('change', async (e) => {
  const f = e.target.files[0];
  if (!f) return;
  tileData = new Uint8Array(await f.arrayBuffer());
  clampActiveStampIndex();
  renderIfReady();
  if (isEditMode) renderStampSelector();
});

filePalette.addEventListener('change', async (e) => {
  const f = e.target.files[0];
  if (!f) return;
  paletteData = new Uint8Array(await f.arrayBuffer());
  paletteRow = 0; // reset to first row
  renderIfReady();
  if (isEditMode) {
    renderStampSelector();
    updateActiveStampPreview();
  }
});

fileStampMap.addEventListener('change', async (e) => {
  const f = e.target.files[0];
  if (!f) {
    stampMapData = null;
    editableStampMapData = null;
    stampMapFilename = null;
  } else {
    stampMapData = new Uint8Array(await f.arrayBuffer());
    editableStampMapData = new Uint8Array(stampMapData);
    stampMapFilename = f.name;
  }
  renderIfReady();
});

btnExport.addEventListener('click', () => {
  try {
    canvas.toBlob((blob) => {
      if (!blob) {
        alert('Unable to export image (canvas is empty).');
        return;
      }
      const a = document.createElement('a');
      const url = URL.createObjectURL(blob);
      a.href = url;
      const filename = `genesis-render-${new Date().toISOString().replace(/[:.]/g,'-')}.png`;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 1000);
    }, 'image/png');
  } catch (err) {
    console.error('Export failed', err);
    alert('Export failed: see console for details.');
  }
});

/* -------------------------
   Palette parsing & preview
   ------------------------- */
function parsePaletteFromData(pData) {
  if (!pData || pData.length < 2) return null;
  const entries = Math.floor(pData.length / 2);
  const palette = new Array(entries);
  for (let i = 0; i < entries; i++) {
    const wordValue = (pData[i * 2] << 8) | pData[i * 2 + 1];
    const blueNib = (wordValue >> 8) & 0x0E;
    const greenNib = (wordValue >> 4) & 0x0E;
    const redNib = wordValue & 0x0E;
    palette[i] = { r: redNib * 17, g: greenNib * 17, b: blueNib * 17 };
  }
  return palette;
}

function showPalettePreview(palette) {
  palettePreview.innerHTML = '';
  if (!palette) {
    paletteRowContainer.style.display = 'none';
    return;
  }
  const max = Math.min(palette.length, 256);

  // Ensure grid columns match the swatch size if you ever change .sw dimensions
  // (keeps layout consistent)
  const swSize = 20;
  palettePreview.style.gridTemplateColumns = `repeat(16, ${swSize}px)`;
  palettePreview.style.gridAutoRows = `${swSize}px`;

  // Calculate number of rows and populate row selector if needed
  const rows = Math.ceil(max / 16);
  if (rows > 1) {
    paletteRowContainer.style.display = 'block';
    paletteRowSelect.innerHTML = '';
    for (let r = 0; r < rows; r++) {
      const opt = document.createElement('option');
      opt.value = r;
      opt.textContent = `Row ${r} (palette indexes ${r*16}–${Math.min((r+1)*16-1, max-1)})`;
      paletteRowSelect.appendChild(opt);
    }
    paletteRowSelect.value = String(paletteRow);
  } else {
    paletteRowContainer.style.display = 'none';
  }

  for (let i = 0; i < max; i++) {
    const p = palette[i];
    const div = document.createElement('div');
    div.className = 'sw';
    div.title = `#${i} rgb(${p.r},${p.g},${p.b})`;
    div.style.backgroundColor = `rgb(${p.r},${p.g},${p.b})`;
    // Highlight the swatches in the selected row
    const thisRow = Math.floor(i / 16);
    if (thisRow === paletteRow) div.classList.add('selected');
    palettePreview.appendChild(div);
  }
}

paletteRowSelect.addEventListener('change', (e) => {
  paletteRow = parseInt(e.target.value, 10) || 0;
  // Refresh palette preview highlighting and re-render view
  const palette = paletteData ? parsePaletteFromData(paletteData) : null;
  showPalettePreview(palette);
  renderIfReady();
});

/* -------------------------
   Progress display helpers
   ------------------------- */
function showProgress(show) {
  progressBar.style.display = show ? 'block' : 'none';
  progressText.style.display = show ? 'block' : 'none';
}

function updateProgress(current, total) {
  const percent = Math.round((current / total) * 100);
  progressFill.style.width = percent + '%';
  progressText.textContent = `Rendering: ${current} / ${total} stamps (${percent}%)`;
}

/* -------------------------
   Active stamp management
   ------------------------- */
function clampActiveStampIndex() {
  if (!tileData) return;
  const stampSize = parseInt(settingStampSize.value, 10);
  const totalTiles = Math.floor(tileData.length / 32);
  const tilesPerDim = stampSize / 8;
  const tilesPerStamp = tilesPerDim * tilesPerDim;
  const maxPhysicalStamps = Math.floor(totalTiles / tilesPerStamp) || 1;
  
  // activeStampIndex is a logical ID, clamp to valid range
  const maxLogicalID = (stampSize === 32) ? maxPhysicalStamps * 4 : maxPhysicalStamps;
  activeStampIndex = Math.max(1, Math.min(activeStampIndex, maxLogicalID));
}

function updateActiveStampPreview() {
  const ctx = activeStampPreview.getContext('2d');
  ctx.imageSmoothingEnabled = false;
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, 64, 64);
  
  if (!tileData || !paletteData || activeStampIndex === 0) return;
  
  const palette = parsePaletteFromData(paletteData);
  const word = ((activeHFlip ? 1 : 0) << 15) | ((activeRotation & 0x03) << 13) | (activeStampIndex & 0x07FF);
  const stampSize = parseInt(settingStampSize.value, 10);
  
  // Render at 2x scale
  const scale = Math.min(2, 64 / stampSize);
  const renderSize = stampSize * scale;
  const offsetX = (64 - renderSize) / 2;
  const offsetY = (64 - renderSize) / 2;
  
  const tempCanvas = document.createElement('canvas');
  tempCanvas.width = stampSize;
  tempCanvas.height = stampSize;
  const tempCtx = tempCanvas.getContext('2d');
  
  renderSingleStamp(tempCtx, word, 0, 0, stampSize, tileData, palette);
  ctx.drawImage(tempCanvas, offsetX, offsetY, renderSize, renderSize);
  
  // Update info text
  activeStampInfo.textContent = `Stamp ${activeStampIndex} | H-Flip: ${activeHFlip} | Rotation: ${activeRotation * 90}°`;
}

function updateActiveStampInfo() {
  activeStampInfo.textContent = `Stamp ${activeStampIndex} | H-Flip: ${activeHFlip} | Rotation: ${activeRotation * 90}°`;
}

/* -------------------------
   Stamp selector rendering
   ------------------------- */
function renderStampSelector() {
  if (!tileData || !paletteData) {
    stampSelector.style.display = 'none';
    return;
  }
  stampSelector.style.display = 'block';
  
  const palette = parsePaletteFromData(paletteData);
  const stampSize = parseInt(settingStampSize.value, 10);
  
  const totalTiles = Math.floor(tileData.length / 32);
  const tilesPerDim = stampSize / 8;
  const tilesPerStamp = tilesPerDim * tilesPerDim;
  const maxPhysicalStamps = Math.floor(totalTiles / tilesPerStamp);
  
  const stampsPerRow = 16;
  const rows = Math.ceil(maxPhysicalStamps / stampsPerRow);
  
  stampSelector.width = stampsPerRow * stampSize;
  stampSelector.height = rows * stampSize;
  stampSelectorCtx.imageSmoothingEnabled = false;
  
  // Clear background
  stampSelectorCtx.fillStyle = '#2a2a2a';
  stampSelectorCtx.fillRect(0, 0, stampSelector.width, stampSelector.height);
  
  // Render physical stamps
  for (let i = 0; i < maxPhysicalStamps; i++) {
    const row = Math.floor(i / stampsPerRow);
    const col = i % stampsPerRow;
    const x = col * stampSize;
    const y = row * stampSize;
    
    // Use first logical ID of each physical stamp's group
    const logicalID = (stampSize === 32) ? (i * 4 + 4) : (i + 4);
    
    renderSingleStamp(stampSelectorCtx, logicalID, x, y, stampSize, tileData, palette);
    
    // Highlight if activeStampIndex belongs to this physical stamp's group
    let shouldHighlight = false;
    if (stampSize === 32) {
      const activeGroup = Math.floor((activeStampIndex - 1) / 4);
      shouldHighlight = (activeGroup === i);
    } else {
      shouldHighlight = (logicalID === activeStampIndex);
    }
    
    if (shouldHighlight) {
      stampSelectorCtx.strokeStyle = '#ff0';
      stampSelectorCtx.lineWidth = 2;
      stampSelectorCtx.strokeRect(x + 1, y + 1, stampSize - 2, stampSize - 2);
    }
  }
}

/* -------------------------
   Single stamp rendering (extracted for reuse)
   ------------------------- */
function renderSingleStamp(ctx, word, destX, destY, stampSize, tileData, palette) {
  const H_MASK = 0x8000;
  const ROT_MASK = 0x6000;
  const STAMP_MASK = 0x07FF;
  
  const hFlip = (word & H_MASK) !== 0;
  const rotation = (word & ROT_MASK) >> 13;
  const stampIndex = word & STAMP_MASK;
  
  if (stampIndex === 0) return; // blank cell
  
  const tilesPerDim = stampSize / 8;
  let stampAddr = stampIndex - 1;
  if (stampSize === 32) stampAddr &= ~0x03;
  const baseTileIndex = stampAddr * 4;
  
  // Create temporary canvas for stamp composition
  const tempCanvas = document.createElement('canvas');
  tempCanvas.width = stampSize;
  tempCanvas.height = stampSize;
  const tempCtx = tempCanvas.getContext('2d');
  const imgData = tempCtx.createImageData(stampSize, stampSize);
  
  // Draw tiles into image data
  for (let sty = 0; sty < tilesPerDim; sty++) {
    for (let stx = 0; stx < tilesPerDim; stx++) {
      const tileIndexInStamp = stx * tilesPerDim + sty;
      drawTileOntoImageData(imgData, baseTileIndex + tileIndexInStamp, tileData, palette, stx * 8, sty * 8);
    }
  }
  
  tempCtx.putImageData(imgData, 0, 0);
  
  // Apply transforms and draw to destination
  const centerX = destX + stampSize / 2;
  const centerY = destY + stampSize / 2;
  
  ctx.save();
  ctx.translate(centerX, centerY);
  ctx.rotate(-rotation * Math.PI / 2);
  
  if (hFlip) {
    if (rotation % 2 === 0) {
      ctx.scale(-1, 1);
    } else {
      ctx.scale(1, -1);
    }
  }
  
  ctx.drawImage(tempCanvas, -stampSize / 2, -stampSize / 2);
  ctx.restore();
}

/* -------------------------
   Single cell re-render (for editing)
   ------------------------- */
function renderStampMapCell(cellIndex, word) {
  if (!stampMapData) return;
  
  const [mapW, mapH] = settingMapSize.value.split('x').map(Number);
  const stampSize = parseInt(settingStampSize.value, 10);
  
  const my = Math.floor(cellIndex / mapW);
  const mx = cellIndex % mapW;
  const destX = mx * stampSize;
  const destY = my * stampSize;
  
  // Clear cell area
  ctx.clearRect(destX, destY, stampSize, stampSize);
  
  // Render stamp if not blank
  if (word !== 0) {
    const palette = paletteData ? parsePaletteFromData(paletteData) : null;
    renderSingleStamp(ctx, word, destX, destY, stampSize, tileData, palette);
  }
}

/* -------------------------
   Main render dispatcher
   ------------------------- */
async function renderIfReady() {
  if (!tileData) return;

  if (renderingInProgress) {
    cancelRendering = true;
    await new Promise(resolve => setTimeout(resolve, 100));
  }

  const palette = paletteData ? parsePaletteFromData(paletteData) : null;
  showPalettePreview(palette);
  
  // Use editable map in edit mode if available
  const mapToRender = (isEditMode && editableStampMapData) ? editableStampMapData : stampMapData;

  if (mapToRender) {
    await renderStampMap(tileData, palette, mapToRender);
  } else {
    renderTileGrid(tileData, palette);
  }
  
  // Draw grid overlay in edit mode
  if (isEditMode && mapToRender) {
    drawGridOverlay();
  }
}

/* -------------------------
   Stamp map rendering (batch mode)
   ------------------------- */
async function renderStampMap(tileData, palette, stampMapData) {
  renderingInProgress = true;
  cancelRendering = false;
  
  const [mapW, mapH] = settingMapSize.value.split('x').map(Number);
  const stampSize = parseInt(settingStampSize.value, 10);

  canvas.width = mapW * stampSize;
  canvas.height = mapH * stampSize;
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  showProgress(true);

  const mapView = new DataView(stampMapData.buffer);
  const totalStamps = mapW * mapH;
  const stampsPerBatch = 100;
  const interBatchDelayMs = 250;
  let currentStamp = 0;

  const processBatch = () => {
    if (cancelRendering) {
      showProgress(false);
      renderingInProgress = false;
      return;
    }

    const batchEnd = Math.min(currentStamp + stampsPerBatch, totalStamps);
    
    for (let i = currentStamp; i < batchEnd; i++) {
      const my = Math.floor(i / mapW);
      const mx = i % mapW;
      const destX = mx * stampSize;
      const destY = my * stampSize;

      if ((i * 2 + 1) >= mapView.byteLength) continue;
      const word = mapView.getUint16(i * 2, false);

      // Always render stamp graphics (no debug hex option)
      renderSingleStamp(ctx, word, destX, destY, stampSize, tileData, palette);
    }

    currentStamp = batchEnd;
    updateProgress(currentStamp, totalStamps);

    if (currentStamp < totalStamps) {
      setTimeout(() => {
        if (!cancelRendering) requestAnimationFrame(processBatch);
      }, interBatchDelayMs);
    } else {
      showProgress(false);
      renderingInProgress = false;
    }
  };

  requestAnimationFrame(processBatch);
}

/* -------------------------
   Grid overlay for edit mode
   ------------------------- */
function drawGridOverlay() {
  const [mapW, mapH] = settingMapSize.value.split('x').map(Number);
  const stampSize = parseInt(settingStampSize.value, 10);
  
  ctx.save();
  ctx.strokeStyle = 'rgba(255,255,255,0.4)';
  ctx.lineWidth = 1;
  
  // Vertical lines
  for (let x = 0; x <= mapW; x++) {
    ctx.beginPath();
    ctx.moveTo(x * stampSize + 0.5, 0);
    ctx.lineTo(x * stampSize + 0.5, canvas.height);
    ctx.stroke();
  }
  
  // Horizontal lines
  for (let y = 0; y <= mapH; y++) {
    ctx.beginPath();
    ctx.moveTo(0, y * stampSize + 0.5);
    ctx.lineTo(canvas.width, y * stampSize + 0.5);
    ctx.stroke();
  }
  
  ctx.restore();
}

/* -------------------------
   Simple tile grid renderer
   ------------------------- */
function renderTileGrid(data, palette) {
  const tileW = 8, tileH = 8;
  const bytesPerTile = 32;
  const tilesPerRow = 32;

  const numTiles = Math.floor(data.length / bytesPerTile);
  if (numTiles === 0) {
    canvas.width = 1; canvas.height = 1;
    ctx.clearRect(0,0,1,1);
    return;
  }

  const imageW = tilesPerRow * tileW;
  const imageH = Math.ceil(numTiles / tilesPerRow) * tileH;
  canvas.width = imageW;
  canvas.height = imageH;
  const img = ctx.createImageData(imageW, imageH);

  for (let t = 0; t < numTiles; t++) {
    const tileX = (t % tilesPerRow) * tileW;
    const tileY = Math.floor(t / tilesPerRow) * tileH;
    drawTileOntoImageData(img, t, data, palette, tileX, tileY);
  }
  ctx.putImageData(img, 0, 0);
}

/* -------------------------
   Tile drawing helper
   ------------------------- */
function drawTileOntoImageData(imgData, tileIndex, tileData, palette, targetX, targetY) {
  const tileW = 8, tileH = 8;
  const bytesPerTile = 32;
  const base = tileIndex * bytesPerTile;
  if (base + bytesPerTile > tileData.length) return;

  const imageW = imgData.width;
  const px = imgData.data;

  for (let row = 0; row < tileH; row++) {
    const rowOffset = base + row * 4;
    for (let col = 0; col < tileW; col++) {
      const byteIndex = rowOffset + (col >> 1);
      const b = tileData[byteIndex];
      const pixelVal = (col & 1) === 0 ? ((b >> 4) & 0x0F) : (b & 0x0F);

      let R = 0, G = 0, B = 0;
      if (pixelVal !== 0) {
        // Use palette row offset when available. Genesis palettes are usually organized as rows of 16 colors.
        const paletteIndex = paletteRow * 16 + pixelVal;
        if (palette && paletteIndex < palette.length) {
          const pcol = palette[paletteIndex];
          R = pcol.r; G = pcol.g; B = pcol.b;
        } else {
          const g = Math.round((pixelVal / 15) * 255);
          R = G = B = g;
        }
      }

      const x = targetX + col;
      const y = targetY + row;
      const di = (y * imageW + x) * 4;
      px[di] = R;
      px[di + 1] = G;
      px[di + 2] = B;
      px[di + 3] = (pixelVal === 0) ? 0 : 255;
    }
  }
}

/* -------------------------
   Edit mode event handlers
   ------------------------- */
settingEditMode.addEventListener('change', (e) => {
  isEditMode = e.target.checked;
  editTools.style.display = isEditMode ? 'block' : 'none';
  canvas.style.cursor = isEditMode ? 'crosshair' : 'default';
  
  if (isEditMode) {
    if (stampMapData && !editableStampMapData) {
      editableStampMapData = new Uint8Array(stampMapData);
    }
    renderStampSelector();
    updateActiveStampPreview();
  }
  renderIfReady();
});

editHFlip.addEventListener('change', (e) => {
  activeHFlip = e.target.checked;
  updateActiveStampPreview();
});

editRotation.addEventListener('change', (e) => {
  activeRotation = parseInt(e.target.value, 10);
  updateActiveStampPreview();
});

// Stamp selector click
stampSelector.addEventListener('click', (e) => {
  if (!tileData || !paletteData) return;
  
  const rect = stampSelector.getBoundingClientRect();
  const scaleX = stampSelector.width / rect.width;
  const scaleY = stampSelector.height / rect.height;
  
  const x = (e.clientX - rect.left) * scaleX;
  const y = (e.clientY - rect.top) * scaleY;
  
  const stampSize = parseInt(settingStampSize.value, 10);
  const stampsPerRow = 16;
  
  const col = Math.floor(x / stampSize);
  const row = Math.floor(y / stampSize);
  const physicalIndex = row * stampsPerRow + col;
  
  const totalTiles = Math.floor(tileData.length / 32);
  const tilesPerDim = stampSize / 8;
  const tilesPerStamp = tilesPerDim * tilesPerDim;
  const maxPhysicalStamps = Math.floor(totalTiles / tilesPerStamp);
  
  if (physicalIndex < maxPhysicalStamps) {
    // Set activeStampIndex to the logical ID for this physical stamp
    activeStampIndex = (stampSize === 32) ? (physicalIndex * 4 + 4) : (physicalIndex + 4);
    updateActiveStampPreview();
    renderStampSelector();
  }
});

// Main canvas click (place stamp)
canvas.addEventListener('click', (e) => {
  if (!isEditMode || !editableStampMapData) return;
  
  const [mapW, mapH] = settingMapSize.value.split('x').map(Number);
  const stampSize = parseInt(settingStampSize.value, 10);
  
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  
  const x = (e.clientX - rect.left) * scaleX;
  const y = (e.clientY - rect.top) * scaleY;
  
  // Clamp coordinates to handle edge cases and rounding errors
  let mx = Math.floor(x / stampSize);
  let my = Math.floor(y / stampSize);
  mx = Math.max(0, Math.min(mapW - 1, mx));
  my = Math.max(0, Math.min(mapH - 1, my));
  
  const cellIndex = my * mapW + mx;
  const mapView = new DataView(editableStampMapData.buffer);
  
  // Convert logical ID to physical ID for saving
  let stampIndexToWrite = activeStampIndex;
  if (stampSize === 32) {
    stampIndexToWrite = ((activeStampIndex - 1) & ~0x03) + 4;
  }
  
  const word = ((activeHFlip ? 1 : 0) << 15) | ((activeRotation & 0x03) << 13) | (stampIndexToWrite & 0x07FF);
  
  // Write to editable map data
  mapView.setUint16(cellIndex * 2, word, false);
  
  // Re-render the cell
  renderStampMapCell(cellIndex, word);
  
  // Redraw grid overlay
  drawGridOverlay();
});

// Main canvas right-click (clear stamp)
canvas.addEventListener('contextmenu', (e) => {
  e.preventDefault();
  if (!isEditMode || !editableStampMapData) return;
  
  const [mapW, mapH] = settingMapSize.value.split('x').map(Number);
  const stampSize = parseInt(settingStampSize.value, 10);
  
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  
  const x = (e.clientX - rect.left) * scaleX;
  const y = (e.clientY - rect.top) * scaleY;
  
  // Clamp coordinates to handle edge cases and rounding errors
  let mx = Math.floor(x / stampSize);
  let my = Math.floor(y / stampSize);
  mx = Math.max(0, Math.min(mapW - 1, mx));
  my = Math.max(0, Math.min(mapH - 1, my));
  
  const cellIndex = my * mapW + mx;
  const mapView = new DataView(editableStampMapData.buffer);
  
  // Clear cell (word = 0)
  mapView.setUint16(cellIndex * 2, 0, false);
  
  // Re-render the cell
  renderStampMapCell(cellIndex, 0);
  
  // Redraw grid overlay
  drawGridOverlay();
});

// Map action buttons
btnNewMap.addEventListener('click', () => {
  if (!confirm('Create a new empty map? This will clear all current data.')) return;
  
  const [mapW, mapH] = settingMapSize.value.split('x').map(Number);
  const totalStamps = mapW * mapH;
  
  // Create empty map (all zeros)
  editableStampMapData = new Uint8Array(totalStamps * 2);
  stampMapData = new Uint8Array(editableStampMapData);
  stampMapFilename = null;
  
  renderIfReady();
});

btnClearMap.addEventListener('click', () => {
  if (!editableStampMapData || !confirm('Clear entire map? This cannot be undone.')) return;
  
  // Fill with zeros
  editableStampMapData.fill(0);
  renderIfReady();
});

btnSaveMap.addEventListener('click', () => {
  if (!editableStampMapData) {
    alert('No map data to save. Load or create a map first.');
    return;
  }
  
  // Create blob and download
  const blob = new Blob([editableStampMapData], { type: 'application/octet-stream' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  const filename = `genesis-map-${new Date().toISOString().replace(/[:.]/g,'-')}.bin`;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(() => URL.revokeObjectURL(url), 1000);
  
  alert(`Map saved as ${filename}`);
});

// Settings change handlers - ensure they work in edit mode
settingMapSize.addEventListener('change', () => {
  if (isEditMode && editableStampMapData) {
    // Convert map data to new size (simple truncation/expansion)
    const [newW, newH] = settingMapSize.value.split('x').map(Number);
    const newSize = newW * newH * 2;
    const newData = new Uint8Array(newSize);
    
    // Copy data (truncate or expand)
    const copySize = Math.min(editableStampMapData.length, newSize);
    newData.set(editableStampMapData.subarray(0, copySize));
    
    editableStampMapData = newData;
    stampMapData = new Uint8Array(newData);
  }
  clampActiveStampIndex();
  renderIfReady();
});

settingStampSize.addEventListener('change', () => {
  clampActiveStampIndex();
  renderIfReady();
  if (isEditMode) {
    renderStampSelector();
    updateActiveStampPreview();
  }
});

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
  if (!isEditMode || !editableStampMapData) return;
  
  // Arrow keys to navigate active stamp (physical stamps)
  if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
    e.preventDefault();
    const stampSize = parseInt(settingStampSize.value, 10);
    const totalTiles = Math.floor(tileData.length / 32);
    const tilesPerDim = stampSize / 8;
    const tilesPerStamp = tilesPerDim * tilesPerDim;
    const maxPhysicalStamps = Math.floor(totalTiles / tilesPerStamp);
    const stampsPerRow = 16;
    
    const currentPhysicalIndex = (stampSize === 32) ? 
      Math.floor((activeStampIndex - 1) / 4) : (activeStampIndex - 1);
    
    let newPhysicalIndex = currentPhysicalIndex;
    if (e.key === 'ArrowUp') {
      newPhysicalIndex = Math.max(0, currentPhysicalIndex - stampsPerRow);
    } else {
      newPhysicalIndex = Math.min(maxPhysicalStamps - 1, currentPhysicalIndex + stampsPerRow);
    }
    
    if (newPhysicalIndex !== currentPhysicalIndex) {
      activeStampIndex = (stampSize === 32) ? 
        (newPhysicalIndex * 4 + 4) : (newPhysicalIndex + 4);
      updateActiveStampPreview();
      renderStampSelector();
    }
  }
  
  // Space to toggle H-flip
  if (e.key === ' ') {
    e.preventDefault();
    activeHFlip = !activeHFlip;
    editHFlip.checked = activeHFlip;
    updateActiveStampPreview();
  }
  
  // R to cycle rotation
  if (e.key.toLowerCase() === 'r') {
    e.preventDefault();
    activeRotation = (activeRotation + 1) % 4;
    editRotation.value = activeRotation;
    updateActiveStampPreview();
  }
});

/* -------------------------
   68K Assembly generation & UI
   ------------------------- */
function mapSourceForAssembly() {
  return (isEditMode && editableStampMapData) ? editableStampMapData : stampMapData;
}

function generate68kAssembly(mapUint8, mapW, mapH, options = {}) {
  // mapUint8 is a Uint8Array holding big-endian words (word 0 at byte 0)
  const dv = new DataView(mapUint8.buffer, mapUint8.byteOffset, mapUint8.byteLength);
  const includeComments = !!options.includeComments;
  const labelAtTop = !!options.labelAtTop;
  let wordsPerLine = parseInt(options.wordsPerLine || 0, 10);
  if (!wordsPerLine || wordsPerLine <= 0) wordsPerLine = mapW; // default to map width

  const total = mapW * mapH;
  const lines = [];

  if (labelAtTop) {
    const label = options.labelName ? sanitizeLabel(options.labelName) : 'stamp_map';
    lines.push(label + ':');
  }

  // Iterate row-major and emit groups of wordsPerLine per line (by default, one assembly line per map row)
  for (let row = 0; row < mapH; row++) {
    let rowWords = [];
    for (let col = 0; col < mapW; col++) {
      const idx = row * mapW + col;
      const byteOff = idx * 2;
      let w = 0;
      if ((byteOff + 1) < dv.byteLength) {
        w = dv.getUint16(byteOff, false); // big-endian (Motorola)
      } else {
        w = 0;
      }
      rowWords.push('$' + w.toString(16).toUpperCase().padStart(4, '0'));
    }

    // If wordsPerLine equals mapW, just emit one dc.w line per row
    if (wordsPerLine === mapW) {
      const comment = includeComments ? ` ; row ${row}` : '';
      lines.push('  dc.w ' + rowWords.join(', ') + comment);
    } else {
      // split rowWords into chunks of wordsPerLine
      for (let i = 0; i < rowWords.length; i += wordsPerLine) {
        const chunk = rowWords.slice(i, i + wordsPerLine);
        const comment = includeComments ? ` ; row ${row} cols ${i}-${Math.min(rowWords.length-1,i+wordsPerLine-1)}` : '';
        lines.push('  dc.w ' + chunk.join(', ') + comment);
      }
    }
  }

  return lines.join('\n');
}

function openAssemblyModal(text, mapLabel) {
  asmText.value = text;
  asmMapSource.textContent = mapLabel || 'ram';
  asmModalBackdrop.style.display = 'flex';
  asmModalBackdrop.setAttribute('aria-hidden', 'false');
  asmText.scrollTop = 0;
}

function closeAssemblyModal() {
  asmModalBackdrop.style.display = 'none';
  asmModalBackdrop.setAttribute('aria-hidden', 'true');
}

btnView68k.addEventListener('click', () => {
  const map = mapSourceForAssembly();
  if (!map) {
    alert('No stamp map loaded. Load a map or create one in edit mode first.');
    return;
  }

  const [mapW, mapH] = settingMapSize.value.split('x').map(Number);
  const includeComments = optIncludeComments.checked;
  const labelAtTop = optLabelAtTop.checked;
  const wordsPerLine = parseInt(optWordsPerLine.value || '0', 10);

  // Generate assembly text
  try {
    const asm = generate68kAssembly(map, mapW, mapH, {
      includeComments,
      labelAtTop,
      wordsPerLine,
      labelName: stampMapFilename
    });
    openAssemblyModal(asm, stampMapFilename || ((isEditMode && editableStampMapData) ? 'editable map' : 'loaded map'));
  } catch (err) {
    console.error('Assembly generation failed', err);
    alert('Failed to generate assembly: see console.');
  }
});

btnAsmClose.addEventListener('click', closeAssemblyModal);

// copy to clipboard
btnAsmCopy.addEventListener('click', async () => {
  try {
    await navigator.clipboard.writeText(asmText.value);
    btnAsmCopy.textContent = 'Copied ✓';
    setTimeout(() => btnAsmCopy.textContent = 'Copy', 1200);
  } catch (err) {
    console.error('Copy failed', err);
    alert('Copy failed — your browser may block clipboard writes.');
  }
});

// download as .asm
btnAsmDownload.addEventListener('click', () => {
  const text = asmText.value;
  if (!text) return;
  const blob = new Blob([text], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  const nameSuffix = (isEditMode && editableStampMapData) ? 'editable' : 'loaded';
  const filename = `stamp_map_${nameSuffix}_${new Date().toISOString().replace(/[:.]/g,'-')}.asm`;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(() => URL.revokeObjectURL(url), 1000);
});

/* Close modal when clicking backdrop outside the modal */
asmModalBackdrop.addEventListener('click', (ev) => {
  if (ev.target === asmModalBackdrop) closeAssemblyModal();
});

/* -------------------------
   Stamp palette export
   ------------------------- */
btnExportStampPalette.addEventListener('click', () => {
  if (!tileData || !paletteData) {
    alert('Need both tiles and palette loaded to export the stamp palette.');
    return;
  }

  const stampSize = parseInt(settingStampSize.value, 10);
  const palette = parsePaletteFromData(paletteData);

  const totalTiles = Math.floor(tileData.length / 32);
  const tilesPerDim = stampSize / 8;
  const tilesPerStamp = tilesPerDim * tilesPerDim;
  const maxPhysicalStamps = Math.floor(totalTiles / tilesPerStamp);

  const stampsPerRow = 16;
  const rows = Math.ceil(maxPhysicalStamps / stampsPerRow);

  const tempCanvas = document.createElement('canvas');
  tempCanvas.width = stampsPerRow * stampSize;
  tempCanvas.height = rows * stampSize;
  const tctx = tempCanvas.getContext('2d');
  tctx.imageSmoothingEnabled = false;

  // Do NOT draw a background (keep transparency)

  for (let i = 0; i < maxPhysicalStamps; i++) {
    const row = Math.floor(i / stampsPerRow);
    const col = i % stampsPerRow;
    const x = col * stampSize;
    const y = row * stampSize;
    const logicalID = (stampSize === 32) ? (i * 4 + 4) : (i + 4);
    renderSingleStamp(tctx, logicalID, x, y, stampSize, tileData, palette);
  }

  tempCanvas.toBlob((blob) => {
    if (!blob) {
      alert('Failed to create PNG');
      return;
    }
    const a = document.createElement('a');
    const url = URL.createObjectURL(blob);
    a.href = url;
    a.download = `stamp_palette_${new Date().toISOString().replace(/[:.]/g,'-')}.png`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 1000);
  }, 'image/png');
});

/* -------------------------
   End of assembly additions
   ------------------------- */

</script>
</body>
</html>
