<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Genesis Tile Viewer & Stamp Map Editor</title>
  <style>
    /* Page layout and typography */
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; padding: 18px; max-width: 1200px; margin: auto; }
    h1 { font-size: 1.2rem; margin-bottom: 10px; }
    label { display:block; margin: 10px 0; }

    /* Canvas styling */
    #canvas { border:1px solid #444; image-rendering: pixelated; display:block; margin-top:12px; max-width: 100%; cursor: crosshair; }
    #stampSelector { border:1px solid #444; cursor:pointer; max-width: 100%; image-rendering: pixelated; }

    /* Palette preview swatches */
    #palettePreview { margin-top:10px; white-space:nowrap; }
    .sw { width:20px; height:20px; display:inline-block; margin:2px; border:1px solid #222; }
    .hint { color:#666; font-size:0.9rem; margin-top:8px; }

    /* Controls layout */
    .controls-container { display: flex; flex-wrap: wrap; gap: 20px; background-color: #f9f9f9; padding: 10px 20px; border-radius: 8px; margin-top: 10px;}
    .control-group { flex: 1; min-width: 250px; }
    .control-group h2 { font-size: 1rem; margin-top: 10px; margin-bottom: 5px; border-bottom: 1px solid #ddd; padding-bottom: 5px; }
    .btn { display:inline-block; margin-top:8px; padding:6px 10px; border-radius:6px; background:#1976d2; color:#fff; border:none; cursor:pointer; }
    .btn:active { transform: translateY(1px); }
    .btn-danger { background:#d32f2f; }
    .btn-success { background:#2e7d32; }

    /* Progress indicator */
    #progressBar { width: 100%; height: 20px; background: #e0e0e0; border-radius: 4px; margin-top: 10px; overflow: hidden; display: none; }
    #progressFill { height: 100%; background: #4CAF50; transition: width 0.2s; width: 0%; }
    #progressText { text-align: center; margin-top: 5px; color: #666; display: none; }

    /* Edit mode UI */
    #editTools { display: none; }
    #activeStampPreview { border:1px solid #444; image-rendering: pixelated; margin-top: 8px; }
    .edit-instruction { color: #1976d2; font-weight: bold; }
  </style>
</head>
<body>
  <h1>Genesis Tile Viewer & Stamp Map Editor</h1>

  <div class="controls-container">
    <!-- Input Files -->
    <div class="control-group">
      <h2>Input Files</h2>
      <label>Tile file (.bin / .unc): <input id="fileTiles" type="file" accept=".bin,.unc" /></label>
      <label>Palette file (.bin / .pal): <input id="filePalette" type="file" accept=".bin,.pal,.unc" /></label>
      <label>Stamp map file (.bin / .unc): <input id="fileStampMap" type="file" accept=".bin,.unc" /></label>
      <button id="btnExport" class="btn" title="Export current canvas to PNG">Export PNG</button>
    </div>

    <!-- Map Settings -->
    <div class="control-group">
      <h2>Stamp Map Settings</h2>
      <label>Map Size (in stamps):
        <select id="settingMapSize">
          <option value="16x16">16x16 stamps (256x256px)</option>
          <option value="8x8">8x8 stamps (256x256px)</option>
          <option value="256x256" selected>256x256 stamps (4096x4096px)</option>
          <option value="128x128">128x128 stamps (4096x4096px)</option>
        </select>
      </label>
      <label>Stamp Size (in pixels):
        <select id="settingStampSize">
          <option value="16" selected>16x16</option>
          <option value="32">32x32</option>
        </select>
      </label>
      <label><input id="settingDebugHex" type="checkbox" /> Show raw hex for each stamp (debug)</label>
      <div class="hint">These settings are only used when a stamp map is loaded.</div>
    </div>

    <!-- Mode & Edit Tools -->
    <div class="control-group">
      <h2>Mode</h2>
      <label><input id="settingEditMode" type="checkbox" /> Enable Edit Mode</label>
      <div class="hint">In edit mode, <span class="edit-instruction">click cells to place stamps</span> and <span class="edit-instruction">right-click to clear</span>.</div>
      
      <div id="editTools">
        <h2 style="margin-top: 15px;">Active Stamp</h2>
        <label>H-Flip: <input type="checkbox" id="editHFlip" /></label>
        <label>Rotation: 
          <select id="editRotation">
            <option value="0" selected>0°</option>
            <option value="1">90°</option>
            <option value="2">180°</option>
            <option value="3">270°</option>
          </select>
        </label>
        <canvas id="activeStampPreview" width="64" height="64"></canvas>
        <div id="activeStampInfo" style="margin-top: 5px; font-size: 0.85rem; color: #666;"></div>
        
        <h2 style="margin-top: 15px;">Stamp Palette</h2>
        <canvas id="stampSelector"></canvas>
        
        <div style="margin-top: 12px;">
          <button id="btnNewMap" class="btn">New Empty Map</button>
          <button id="btnClearMap" class="btn btn-danger">Clear Entire Map</button>
          <button id="btnSaveMap" class="btn btn-success">Save Map</button>
        </div>
      </div>
    </div>
  </div>

  <div class="hint">Tiles are assumed 8×8, 4bpp (32 bytes per tile). Without a map, tiles are shown in a 32-wide grid.</div>

  <!-- Progress indicators -->
  <div id="progressBar"><div id="progressFill"></div></div>
  <div id="progressText"></div>

  <!-- Canvas where the tile grid or stamp map is drawn -->
  <canvas id="canvas"></canvas>

  <!-- Palette preview -->
  <div id="palettePreview"></div>

<script>
/* -------------------------
   DOM references & state
   ------------------------- */
const fileTiles = document.getElementById('fileTiles');
const filePalette = document.getElementById('filePalette');
const fileStampMap = document.getElementById('fileStampMap');
const settingMapSize = document.getElementById('settingMapSize');
const settingStampSize = document.getElementById('settingStampSize');
const settingDebugHex = document.getElementById('settingDebugHex');
const settingEditMode = document.getElementById('settingEditMode');
const btnExport = document.getElementById('btnExport');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const palettePreview = document.getElementById('palettePreview');
const progressBar = document.getElementById('progressBar');
const progressFill = document.getElementById('progressFill');
const progressText = document.getElementById('progressText');

// Edit mode elements
const editTools = document.getElementById('editTools');
const editHFlip = document.getElementById('editHFlip');
const editRotation = document.getElementById('editRotation');
const activeStampPreview = document.getElementById('activeStampPreview');
const activeStampInfo = document.getElementById('activeStampInfo');
const stampSelector = document.getElementById('stampSelector');
const stampSelectorCtx = stampSelector.getContext('2d');
const btnNewMap = document.getElementById('btnNewMap');
const btnClearMap = document.getElementById('btnClearMap');
const btnSaveMap = document.getElementById('btnSaveMap');

// State
let tileData = null;
let paletteData = null;
let stampMapData = null;
let editableStampMapData = null;
let renderingInProgress = false;
let cancelRendering = false;
let isEditMode = false;
let activeStampIndex = 1;
let activeHFlip = false;
let activeRotation = 0;

/* -------------------------
   File input handlers
   ------------------------- */
fileTiles.addEventListener('change', async (e) => {
  const f = e.target.files[0];
  if (!f) return;
  tileData = new Uint8Array(await f.arrayBuffer());
  clampActiveStampIndex();
  renderIfReady();
  if (isEditMode) renderStampSelector();
});

filePalette.addEventListener('change', async (e) => {
  const f = e.target.files[0];
  if (!f) return;
  paletteData = new Uint8Array(await f.arrayBuffer());
  renderIfReady();
  if (isEditMode) {
    renderStampSelector();
    updateActiveStampPreview();
  }
});

fileStampMap.addEventListener('change', async (e) => {
  const f = e.target.files[0];
  if (!f) {
    stampMapData = null;
    editableStampMapData = null;
  } else {
    stampMapData = new Uint8Array(await f.arrayBuffer());
    editableStampMapData = new Uint8Array(stampMapData);
  }
  renderIfReady();
});

btnExport.addEventListener('click', () => {
  try {
    canvas.toBlob((blob) => {
      if (!blob) {
        alert('Unable to export image (canvas is empty).');
        return;
      }
      const a = document.createElement('a');
      const url = URL.createObjectURL(blob);
      a.href = url;
      const filename = `genesis-render-${new Date().toISOString().replace(/[:.]/g,'-')}.png`;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 1000);
    }, 'image/png');
  } catch (err) {
    console.error('Export failed', err);
    alert('Export failed: see console for details.');
  }
});

/* -------------------------
   Palette parsing & preview
   ------------------------- */
function parsePaletteFromData(pData) {
  if (!pData || pData.length < 2) return null;
  const entries = Math.floor(pData.length / 2);
  const palette = new Array(entries);
  for (let i = 0; i < entries; i++) {
    const wordValue = (pData[i * 2] << 8) | pData[i * 2 + 1];
    const blueNib = (wordValue >> 8) & 0x0E;
    const greenNib = (wordValue >> 4) & 0x0E;
    const redNib = wordValue & 0x0E;
    palette[i] = { r: redNib * 17, g: greenNib * 17, b: blueNib * 17 };
  }
  return palette;
}

function showPalettePreview(palette) {
  palettePreview.innerHTML = '';
  if (!palette) return;
  const max = Math.min(palette.length, 256);
  for (let i = 0; i < max; i++) {
    const p = palette[i];
    const div = document.createElement('div');
    div.className = 'sw';
    div.title = `#${i} rgb(${p.r},${p.g},${p.b})`;
    div.style.backgroundColor = `rgb(${p.r},${p.g},${p.b})`;
    palettePreview.appendChild(div);
  }
}

/* -------------------------
   Progress display helpers
   ------------------------- */
function showProgress(show) {
  progressBar.style.display = show ? 'block' : 'none';
  progressText.style.display = show ? 'block' : 'none';
}

function updateProgress(current, total) {
  const percent = Math.round((current / total) * 100);
  progressFill.style.width = percent + '%';
  progressText.textContent = `Rendering: ${current} / ${total} stamps (${percent}%)`;
}

/* -------------------------
   Active stamp management
   ------------------------- */
function clampActiveStampIndex() {
  if (!tileData) return;
  const stampSize = parseInt(settingStampSize.value, 10);
  const totalTiles = Math.floor(tileData.length / 32);
  const tilesPerDim = stampSize / 8;
  const tilesPerStamp = tilesPerDim * tilesPerDim;
  const maxPhysicalStamps = Math.floor(totalTiles / tilesPerStamp) || 1;
  
  // activeStampIndex is a logical ID, clamp to valid range
  const maxLogicalID = (stampSize === 32) ? maxPhysicalStamps * 4 : maxPhysicalStamps;
  activeStampIndex = Math.max(1, Math.min(activeStampIndex, maxLogicalID));
}

function updateActiveStampPreview() {
  const ctx = activeStampPreview.getContext('2d');
  ctx.imageSmoothingEnabled = false;
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, 64, 64);
  
  if (!tileData || !paletteData || activeStampIndex === 0) return;
  
  const palette = parsePaletteFromData(paletteData);
  const word = ((activeHFlip ? 1 : 0) << 15) | ((activeRotation & 0x03) << 13) | (activeStampIndex & 0x07FF);
  const stampSize = parseInt(settingStampSize.value, 10);
  
  // Render at 2x scale
  const scale = Math.min(2, 64 / stampSize);
  const renderSize = stampSize * scale;
  const offsetX = (64 - renderSize) / 2;
  const offsetY = (64 - renderSize) / 2;
  
  const tempCanvas = document.createElement('canvas');
  tempCanvas.width = stampSize;
  tempCanvas.height = stampSize;
  const tempCtx = tempCanvas.getContext('2d');
  
  renderSingleStamp(tempCtx, word, 0, 0, stampSize, tileData, palette);
  ctx.drawImage(tempCanvas, offsetX, offsetY, renderSize, renderSize);
  
  // Update info text
  activeStampInfo.textContent = `Stamp ${activeStampIndex} | H-Flip: ${activeHFlip} | Rotation: ${activeRotation * 90}°`;
}

function updateActiveStampInfo() {
  activeStampInfo.textContent = `Stamp ${activeStampIndex} | H-Flip: ${activeHFlip} | Rotation: ${activeRotation * 90}°`;
}

/* -------------------------
   Stamp selector rendering
   ------------------------- */
function renderStampSelector() {
  if (!tileData || !paletteData) {
    stampSelector.style.display = 'none';
    return;
  }
  stampSelector.style.display = 'block';
  
  const palette = parsePaletteFromData(paletteData);
  const stampSize = parseInt(settingStampSize.value, 10);
  
  const totalTiles = Math.floor(tileData.length / 32);
  const tilesPerDim = stampSize / 8;
  const tilesPerStamp = tilesPerDim * tilesPerDim;
  const maxPhysicalStamps = Math.floor(totalTiles / tilesPerStamp);
  
  const stampsPerRow = 16;
  const rows = Math.ceil(maxPhysicalStamps / stampsPerRow);
  
  stampSelector.width = stampsPerRow * stampSize;
  stampSelector.height = rows * stampSize;
  stampSelectorCtx.imageSmoothingEnabled = false;
  
  // Clear background
  stampSelectorCtx.fillStyle = '#2a2a2a';
  stampSelectorCtx.fillRect(0, 0, stampSelector.width, stampSelector.height);
  
  // Render physical stamps
  for (let i = 0; i < maxPhysicalStamps; i++) {
    const row = Math.floor(i / stampsPerRow);
    const col = i % stampsPerRow;
    const x = col * stampSize;
    const y = row * stampSize;
    
    // Use first logical ID of each physical stamp's group
    const logicalID = (stampSize === 32) ? (i * 4 + 1) : (i + 1);
    
    renderSingleStamp(stampSelectorCtx, logicalID, x, y, stampSize, tileData, palette);
    
    // Highlight if activeStampIndex belongs to this physical stamp's group
    let shouldHighlight = false;
    if (stampSize === 32) {
      const activeGroup = Math.floor((activeStampIndex - 1) / 4);
      shouldHighlight = (activeGroup === i);
    } else {
      shouldHighlight = (logicalID === activeStampIndex);
    }
    
    if (shouldHighlight) {
      stampSelectorCtx.strokeStyle = '#ff0';
      stampSelectorCtx.lineWidth = 2;
      stampSelectorCtx.strokeRect(x + 1, y + 1, stampSize - 2, stampSize - 2);
    }
  }
}

/* -------------------------
   Single stamp rendering (extracted for reuse)
   ------------------------- */
function renderSingleStamp(ctx, word, destX, destY, stampSize, tileData, palette) {
  const H_MASK = 0x8000;
  const ROT_MASK = 0x6000;
  const STAMP_MASK = 0x07FF;
  
  const hFlip = (word & H_MASK) !== 0;
  const rotation = (word & ROT_MASK) >> 13;
  const stampIndex = word & STAMP_MASK;
  
  if (stampIndex === 0) return; // blank cell
  
  const tilesPerDim = stampSize / 8;
  let stampAddr = stampIndex - 1;
  if (stampSize === 32) stampAddr &= ~0x03;
  const baseTileIndex = stampAddr * 4;
  
  // Create temporary canvas for stamp composition
  const tempCanvas = document.createElement('canvas');
  tempCanvas.width = stampSize;
  tempCanvas.height = stampSize;
  const tempCtx = tempCanvas.getContext('2d');
  const imgData = tempCtx.createImageData(stampSize, stampSize);
  
  // Draw tiles into image data
  for (let sty = 0; sty < tilesPerDim; sty++) {
    for (let stx = 0; stx < tilesPerDim; stx++) {
      const tileIndexInStamp = stx * tilesPerDim + sty;
      drawTileOntoImageData(imgData, baseTileIndex + tileIndexInStamp, tileData, palette, stx * 8, sty * 8);
    }
  }
  
  tempCtx.putImageData(imgData, 0, 0);
  
  // Apply transforms and draw to destination
  const centerX = destX + stampSize / 2;
  const centerY = destY + stampSize / 2;
  
  ctx.save();
  ctx.translate(centerX, centerY);
  ctx.rotate(-rotation * Math.PI / 2);
  
  if (hFlip) {
    if (rotation % 2 === 0) {
      ctx.scale(-1, 1);
    } else {
      ctx.scale(1, -1);
    }
  }
  
  ctx.drawImage(tempCanvas, -stampSize / 2, -stampSize / 2);
  ctx.restore();
}

/* -------------------------
   Single cell re-render (for editing)
   ------------------------- */
function renderStampMapCell(cellIndex, word) {
  if (!stampMapData) return;
  
  const [mapW, mapH] = settingMapSize.value.split('x').map(Number);
  const stampSize = parseInt(settingStampSize.value, 10);
  
  const my = Math.floor(cellIndex / mapW);
  const mx = cellIndex % mapW;
  const destX = mx * stampSize;
  const destY = my * stampSize;
  
  // Clear cell area
  ctx.clearRect(destX, destY, stampSize, stampSize);
  
  // Render stamp if not blank
  if (word !== 0) {
    const palette = paletteData ? parsePaletteFromData(paletteData) : null;
    renderSingleStamp(ctx, word, destX, destY, stampSize, tileData, palette);
  }
}

/* -------------------------
   Main render dispatcher
   ------------------------- */
async function renderIfReady() {
  if (!tileData) return;

  if (renderingInProgress) {
    cancelRendering = true;
    await new Promise(resolve => setTimeout(resolve, 100));
  }

  const palette = paletteData ? parsePaletteFromData(paletteData) : null;
  showPalettePreview(palette);
  
  // Use editable map in edit mode if available
  const mapToRender = (isEditMode && editableStampMapData) ? editableStampMapData : stampMapData;

  if (mapToRender) {
    await renderStampMap(tileData, palette, mapToRender);
  } else {
    renderTileGrid(tileData, palette);
  }
  
  // Draw grid overlay in edit mode
  if (isEditMode && mapToRender) {
    drawGridOverlay();
  }
}

/* -------------------------
   Stamp map rendering (batch mode)
   ------------------------- */
async function renderStampMap(tileData, palette, stampMapData) {
  renderingInProgress = true;
  cancelRendering = false;
  
  const [mapW, mapH] = settingMapSize.value.split('x').map(Number);
  const stampSize = parseInt(settingStampSize.value, 10);

  canvas.width = mapW * stampSize;
  canvas.height = mapH * stampSize;
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  showProgress(true);

  const debugHex = settingDebugHex.checked;
  const mapView = new DataView(stampMapData.buffer);
  const totalStamps = mapW * mapH;
  const stampsPerBatch = 100;
  const interBatchDelayMs = 250;
  let currentStamp = 0;

  const processBatch = () => {
    if (cancelRendering) {
      showProgress(false);
      renderingInProgress = false;
      return;
    }

    const batchEnd = Math.min(currentStamp + stampsPerBatch, totalStamps);
    
    for (let i = currentStamp; i < batchEnd; i++) {
      const my = Math.floor(i / mapW);
      const mx = i % mapW;
      const destX = mx * stampSize;
      const destY = my * stampSize;

      if ((i * 2 + 1) >= mapView.byteLength) continue;
      const word = mapView.getUint16(i * 2, false);

      if (debugHex) {
        if (word === 0) {
          ctx.fillStyle = '#f5f5f5';
        } else {
          ctx.fillStyle = '#e8e8ff';
        }
        ctx.fillRect(destX, destY, stampSize, stampSize);
        ctx.strokeStyle = '#bbb';
        ctx.strokeRect(destX + 0.5, destY + 0.5, stampSize - 1, stampSize - 1);
        ctx.fillStyle = '#111';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const fontSize = Math.max(8, Math.floor(stampSize / 3));
        ctx.font = `${fontSize}px monospace`;
        ctx.fillText('0x' + word.toString(16).toUpperCase().padStart(4,'0'), destX + stampSize / 2, destY + stampSize / 2);
      } else {
        renderSingleStamp(ctx, word, destX, destY, stampSize, tileData, palette);
      }
    }

    currentStamp = batchEnd;
    updateProgress(currentStamp, totalStamps);

    if (currentStamp < totalStamps) {
      setTimeout(() => {
        if (!cancelRendering) requestAnimationFrame(processBatch);
      }, interBatchDelayMs);
    } else {
      showProgress(false);
      renderingInProgress = false;
    }
  };

  requestAnimationFrame(processBatch);
}

/* -------------------------
   Grid overlay for edit mode
   ------------------------- */
function drawGridOverlay() {
  const [mapW, mapH] = settingMapSize.value.split('x').map(Number);
  const stampSize = parseInt(settingStampSize.value, 10);
  
  ctx.save();
  ctx.strokeStyle = 'rgba(255,255,255,0.4)';
  ctx.lineWidth = 1;
  
  // Vertical lines
  for (let x = 0; x <= mapW; x++) {
    ctx.beginPath();
    ctx.moveTo(x * stampSize + 0.5, 0);
    ctx.lineTo(x * stampSize + 0.5, canvas.height);
    ctx.stroke();
  }
  
  // Horizontal lines
  for (let y = 0; y <= mapH; y++) {
    ctx.beginPath();
    ctx.moveTo(0, y * stampSize + 0.5);
    ctx.lineTo(canvas.width, y * stampSize + 0.5);
    ctx.stroke();
  }
  
  ctx.restore();
}

/* -------------------------
   Simple tile grid renderer
   ------------------------- */
function renderTileGrid(data, palette) {
  const tileW = 8, tileH = 8;
  const bytesPerTile = 32;
  const tilesPerRow = 32;

  const numTiles = Math.floor(data.length / bytesPerTile);
  if (numTiles === 0) {
    canvas.width = 1; canvas.height = 1;
    ctx.clearRect(0,0,1,1);
    return;
  }

  const imageW = tilesPerRow * tileW;
  const imageH = Math.ceil(numTiles / tilesPerRow) * tileH;
  canvas.width = imageW;
  canvas.height = imageH;
  const img = ctx.createImageData(imageW, imageH);

  for (let t = 0; t < numTiles; t++) {
    const tileX = (t % tilesPerRow) * tileW;
    const tileY = Math.floor(t / tilesPerRow) * tileH;
    drawTileOntoImageData(img, t, data, palette, tileX, tileY);
  }
  ctx.putImageData(img, 0, 0);
}

/* -------------------------
   Tile drawing helper
   ------------------------- */
function drawTileOntoImageData(imgData, tileIndex, tileData, palette, targetX, targetY) {
  const tileW = 8, tileH = 8;
  const bytesPerTile = 32;
  const base = tileIndex * bytesPerTile;
  if (base + bytesPerTile > tileData.length) return;

  const imageW = imgData.width;
  const px = imgData.data;

  for (let row = 0; row < tileH; row++) {
    const rowOffset = base + row * 4;
    for (let col = 0; col < tileW; col++) {
      const byteIndex = rowOffset + (col >> 1);
      const b = tileData[byteIndex];
      const pixelVal = (col & 1) === 0 ? ((b >> 4) & 0x0F) : (b & 0x0F);

      let R = 0, G = 0, B = 0;
      if (pixelVal !== 0) {
        if (palette && pixelVal < palette.length) {
          const pcol = palette[pixelVal];
          R = pcol.r; G = pcol.g; B = pcol.b;
        } else {
          const g = Math.round((pixelVal / 15) * 255);
          R = G = B = g;
        }
      }

      const x = targetX + col;
      const y = targetY + row;
      const di = (y * imageW + x) * 4;
      px[di] = R;
      px[di + 1] = G;
      px[di + 2] = B;
      px[di + 3] = (pixelVal === 0) ? 0 : 255;
    }
  }
}

/* -------------------------
   Edit mode event handlers
   ------------------------- */
settingEditMode.addEventListener('change', (e) => {
  isEditMode = e.target.checked;
  editTools.style.display = isEditMode ? 'block' : 'none';
  canvas.style.cursor = isEditMode ? 'crosshair' : 'default';
  
  if (isEditMode) {
    if (stampMapData && !editableStampMapData) {
      editableStampMapData = new Uint8Array(stampMapData);
    }
    renderStampSelector();
    updateActiveStampPreview();
  }
  renderIfReady();
});

editHFlip.addEventListener('change', (e) => {
  activeHFlip = e.target.checked;
  updateActiveStampPreview();
});

editRotation.addEventListener('change', (e) => {
  activeRotation = parseInt(e.target.value, 10);
  updateActiveStampPreview();
});

// Stamp selector click
stampSelector.addEventListener('click', (e) => {
  if (!tileData || !paletteData) return;
  
  const rect = stampSelector.getBoundingClientRect();
  const scaleX = stampSelector.width / rect.width;
  const scaleY = stampSelector.height / rect.height;
  
  const x = (e.clientX - rect.left) * scaleX;
  const y = (e.clientY - rect.top) * scaleY;
  
  const stampSize = parseInt(settingStampSize.value, 10);
  const stampsPerRow = 16;
  
  const col = Math.floor(x / stampSize);
  const row = Math.floor(y / stampSize);
  const physicalIndex = row * stampsPerRow + col;
  
  const totalTiles = Math.floor(tileData.length / 32);
  const tilesPerDim = stampSize / 8;
  const tilesPerStamp = tilesPerDim * tilesPerDim;
  const maxPhysicalStamps = Math.floor(totalTiles / tilesPerStamp);
  
  if (physicalIndex < maxPhysicalStamps) {
    // Set activeStampIndex to the logical ID for this physical stamp
    activeStampIndex = (stampSize === 32) ? (physicalIndex * 4 + 1) : (physicalIndex + 1);
    updateActiveStampPreview();
    renderStampSelector();
  }
});

// Main canvas click (place stamp)
canvas.addEventListener('click', (e) => {
  if (!isEditMode || !editableStampMapData) return;
  
  const [mapW, mapH] = settingMapSize.value.split('x').map(Number);
  const stampSize = parseInt(settingStampSize.value, 10);
  
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  
  const x = (e.clientX - rect.left) * scaleX;
  const y = (e.clientY - rect.top) * scaleY;
  
  // Clamp coordinates to handle edge cases and rounding errors
  let mx = Math.floor(x / stampSize);
  let my = Math.floor(y / stampSize);
  mx = Math.max(0, Math.min(mapW - 1, mx));
  my = Math.max(0, Math.min(mapH - 1, my));
  
  const cellIndex = my * mapW + mx;
  const mapView = new DataView(editableStampMapData.buffer);
  
  // Convert logical ID to physical ID for saving
  let stampIndexToWrite = activeStampIndex;
  if (stampSize === 32) {
    stampIndexToWrite = ((activeStampIndex - 1) & ~0x03) + 1;
  }
  
  const word = ((activeHFlip ? 1 : 0) << 15) | ((activeRotation & 0x03) << 13) | (stampIndexToWrite & 0x07FF);
  
  // Write to editable map data
  mapView.setUint16(cellIndex * 2, word, false);
  
  // Re-render the cell
  renderStampMapCell(cellIndex, word);
  
  // Redraw grid overlay
  drawGridOverlay();
});

// Main canvas right-click (clear stamp)
canvas.addEventListener('contextmenu', (e) => {
  e.preventDefault();
  if (!isEditMode || !editableStampMapData) return;
  
  const [mapW, mapH] = settingMapSize.value.split('x').map(Number);
  const stampSize = parseInt(settingStampSize.value, 10);
  
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  
  const x = (e.clientX - rect.left) * scaleX;
  const y = (e.clientY - rect.top) * scaleY;
  
  // Clamp coordinates to handle edge cases and rounding errors
  let mx = Math.floor(x / stampSize);
  let my = Math.floor(y / stampSize);
  mx = Math.max(0, Math.min(mapW - 1, mx));
  my = Math.max(0, Math.min(mapH - 1, my));
  
  const cellIndex = my * mapW + mx;
  const mapView = new DataView(editableStampMapData.buffer);
  
  // Clear cell (word = 0)
  mapView.setUint16(cellIndex * 2, 0, false);
  
  // Re-render the cell
  renderStampMapCell(cellIndex, 0);
  
  // Redraw grid overlay
  drawGridOverlay();
});

// Map action buttons
btnNewMap.addEventListener('click', () => {
  if (!confirm('Create a new empty map? This will clear all current data.')) return;
  
  const [mapW, mapH] = settingMapSize.value.split('x').map(Number);
  const totalStamps = mapW * mapH;
  
  // Create empty map (all zeros)
  editableStampMapData = new Uint8Array(totalStamps * 2);
  stampMapData = new Uint8Array(editableStampMapData);
  
  renderIfReady();
});

btnClearMap.addEventListener('click', () => {
  if (!editableStampMapData || !confirm('Clear entire map? This cannot be undone.')) return;
  
  // Fill with zeros
  editableStampMapData.fill(0);
  renderIfReady();
});

btnSaveMap.addEventListener('click', () => {
  if (!editableStampMapData) {
    alert('No map data to save. Load or create a map first.');
    return;
  }
  
  // Create blob and download
  const blob = new Blob([editableStampMapData], { type: 'application/octet-stream' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  const filename = `genesis-map-${new Date().toISOString().replace(/[:.]/g,'-')}.bin`;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(() => URL.revokeObjectURL(url), 1000);
  
  alert(`Map saved as ${filename}`);
});

// Settings change handlers - ensure they work in edit mode
settingMapSize.addEventListener('change', () => {
  if (isEditMode && editableStampMapData) {
    // Convert map data to new size (simple truncation/expansion)
    const [newW, newH] = settingMapSize.value.split('x').map(Number);
    const newSize = newW * newH * 2;
    const newData = new Uint8Array(newSize);
    
    // Copy data (truncate or expand)
    const copySize = Math.min(editableStampMapData.length, newSize);
    newData.set(editableStampMapData.subarray(0, copySize));
    
    editableStampMapData = newData;
    stampMapData = new Uint8Array(newData);
  }
  clampActiveStampIndex();
  renderIfReady();
});

settingStampSize.addEventListener('change', () => {
  clampActiveStampIndex();
  renderIfReady();
  if (isEditMode) {
    renderStampSelector();
    updateActiveStampPreview();
  }
});

settingDebugHex.addEventListener('change', renderIfReady);

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
  if (!isEditMode || !editableStampMapData) return;
  
  // Arrow keys to navigate active stamp (physical stamps)
  if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
    e.preventDefault();
    const stampSize = parseInt(settingStampSize.value, 10);
    const totalTiles = Math.floor(tileData.length / 32);
    const tilesPerDim = stampSize / 8;
    const tilesPerStamp = tilesPerDim * tilesPerDim;
    const maxPhysicalStamps = Math.floor(totalTiles / tilesPerStamp);
    const stampsPerRow = 16;
    
    const currentPhysicalIndex = (stampSize === 32) ? 
      Math.floor((activeStampIndex - 1) / 4) : (activeStampIndex - 1);
    
    let newPhysicalIndex = currentPhysicalIndex;
    if (e.key === 'ArrowUp') {
      newPhysicalIndex = Math.max(0, currentPhysicalIndex - stampsPerRow);
    } else {
      newPhysicalIndex = Math.min(maxPhysicalStamps - 1, currentPhysicalIndex + stampsPerRow);
    }
    
    if (newPhysicalIndex !== currentPhysicalIndex) {
      activeStampIndex = (stampSize === 32) ? 
        (newPhysicalIndex * 4 + 1) : (newPhysicalIndex + 1);
      updateActiveStampPreview();
      renderStampSelector();
    }
  }
  
  // Space to toggle H-flip
  if (e.key === ' ') {
    e.preventDefault();
    activeHFlip = !activeHFlip;
    editHFlip.checked = activeHFlip;
    updateActiveStampPreview();
  }
  
  // R to cycle rotation
  if (e.key.toLowerCase() === 'r') {
    e.preventDefault();
    activeRotation = (activeRotation + 1) % 4;
    editRotation.value = activeRotation;
    updateActiveStampPreview();
  }
});
</script>
</body>
</html>
