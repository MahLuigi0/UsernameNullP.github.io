<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Genesis Tile Viewer with Stamp Map Support</title>
  <style>
    /* Page layout and typography */
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; padding: 18px; max-width: 1000px; margin: auto; }
    h1 { font-size: 1.2rem; margin-bottom: 10px; }
    label { display:block; margin: 10px 0; }

    /* Canvas styling — 'image-rendering: pixelated' keeps pixels crisp when scaled */
    #canvas { border:1px solid #444; image-rendering: pixelated; display:block; margin-top:12px; max-width: 100%; }

    /* Palette preview swatches */
    #palettePreview { margin-top:10px; white-space:nowrap; }
    .sw { width:20px; height:20px; display:inline-block; margin:2px; border:1px solid #222; }
    .hint { color:#666; font-size:0.9rem; margin-top:8px; }

    /* Controls layout */
    .controls-container { display: flex; flex-wrap: wrap; gap: 40px; background-color: #f9f9f9; padding: 10px 20px; border-radius: 8px; margin-top: 10px;}
    .control-group h2 { font-size: 1rem; margin-top: 10px; margin-bottom: 5px; border-bottom: 1px solid #ddd; padding-bottom: 5px; }
    .btn { display:inline-block; margin-top:8px; padding:6px 10px; border-radius:6px; background:#1976d2; color:#fff; border:none; cursor:pointer; }
    .btn:active { transform: translateY(1px); }

    /* Progress indicator */
    #progressBar { width: 100%; height: 20px; background: #e0e0e0; border-radius: 4px; margin-top: 10px; overflow: hidden; display: none; }
    #progressFill { height: 100%; background: #4CAF50; transition: width 0.2s; width: 0%; }
    #progressText { text-align: center; margin-top: 5px; color: #666; display: none; }
  </style>
</head>
<body>
  <h1>Genesis Tile Viewer — with Stamp Map Support</h1>

  <!-- Controls for loading files and changing stamp/map settings -->
  <div class="controls-container">
    <div class="control-group">
      <h2>Input Files</h2>
      <!-- Tile file: expected 4bpp 8x8 tiles packed as 32 bytes per tile -->
      <label>Tile file (.bin / .unc): <input id="fileTiles" type="file" accept=".bin,.unc" /></label>
      <!-- Palette file: 16-bit words (Genesis/MD 9-bit RGB style packed in 2 bytes) -->
      <label>Palette file (.bin / .pal): <input id="filePalette" type="file" accept=".bin,.pal,.unc" /></label>
      <!-- Stamp map file: optional; when provided the viewer draws a stamp map rather than grid -->
      <label>Stamp map file (.bin / .unc): <input id="fileStampMap" type="file" accept=".bin,.unc" /></label>
      <button id="btnExport" class="btn" title="Export current canvas to PNG">Export PNG</button>
    </div>

    <div class="control-group">
      <h2>Stamp Map Settings</h2>
      <!-- Map size determines stamp grid dimensions (interpreted in stamps) -->
      <label>Map Size (in stamps):
        <select id="settingMapSize">
          <option value="16x16">16x16 stamps (for 256x256px map)</option>
          <option value="8x8">8x8 stamps (for 256x256px map)</option>
          <option value="256x256" selected>256x256 stamps (for 4096x4096px map)</option>
          <option value="128x128">128x128 stamps (for 4096x4096px map)</option>
        </select>
      </label>

      <!-- Stamp size: typical Genesis stamp pack sizes are 16x16 or 32x32 pixels -->
      <label>Stamp Size (in pixels):
        <select id="settingStampSize">
          <option value="16">16x16</option>
          <option value="32">32x32</option>
        </select>
      </label>

      <!-- Debug option to show hex values instead of drawing stamps -->
      <label><input id="settingDebugHex" type="checkbox" /> Show raw hex for each stamp (debug) — no flipping/rotation</label>

      <div class="hint">These settings are only used when a stamp map is loaded.</div>
    </div>
  </div>

  <div class="hint">Tiles are assumed 8×8, 4bpp (32 bytes per tile). Without a map, tiles are shown in a 32-wide grid.</div>

  <!-- Progress indicators -->
  <div id="progressBar"><div id="progressFill"></div></div>
  <div id="progressText"></div>

  <!-- Canvas where the tile grid or stamp map is drawn -->
  <canvas id="canvas"></canvas>

  <!-- Small preview of the loaded palette -->
  <div id="palettePreview"></div>

<script>
/* -------------------------
   DOM references & state
   ------------------------- */
const fileTiles = document.getElementById('fileTiles');
const filePalette = document.getElementById('filePalette');
const fileStampMap = document.getElementById('fileStampMap');
const settingMapSize = document.getElementById('settingMapSize');
const settingStampSize = document.getElementById('settingStampSize');
const settingDebugHex = document.getElementById('settingDebugHex');
const btnExport = document.getElementById('btnExport');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const palettePreview = document.getElementById('palettePreview');
const progressBar = document.getElementById('progressBar');
const progressFill = document.getElementById('progressFill');
const progressText = document.getElementById('progressText');

let tileData = null;     // Uint8Array for raw tile file bytes
let paletteData = null;  // Uint8Array for raw palette bytes
let stampMapData = null; // Uint8Array for raw stamp map bytes
let renderingInProgress = false;
let cancelRendering = false;

/* -------------------------
   File input handlers
   ------------------------- */
/* Load tile file into tileData (Uint8Array) then attempt render */
fileTiles.addEventListener('change', async (e) => {
  const f = e.target.files[0];
  if (!f) return;
  tileData = new Uint8Array(await f.arrayBuffer());
  renderIfReady();
});

/* Load palette file into paletteData (Uint8Array) then attempt render */
filePalette.addEventListener('change', async (e) => {
  const f = e.target.files[0];
  if (!f) return;
  paletteData = new Uint8Array(await f.arrayBuffer());
  renderIfReady();
});

/* Load or clear stamp map file; stamp map is optional */
fileStampMap.addEventListener('change', async (e) => {
  const f = e.target.files[0];
  if (!f) {
    stampMapData = null;
  } else {
    stampMapData = new Uint8Array(await f.arrayBuffer());
  }
  renderIfReady();
});

/* Changing stamp/map settings triggers a re-render */
settingMapSize.addEventListener('change', renderIfReady);
settingStampSize.addEventListener('change', renderIfReady);
settingDebugHex.addEventListener('change', renderIfReady);

/* Export button handler */
btnExport.addEventListener('click', () => {
  try {
    // Use toBlob for better memory handling and to avoid dataURL size issues
    canvas.toBlob((blob) => {
      if (!blob) {
        alert('Unable to export image (canvas is empty).');
        return;
      }
      const a = document.createElement('a');
      const url = URL.createObjectURL(blob);
      a.href = url;
      const filename = `genesis-render-${new Date().toISOString().replace(/[:.]/g,'-')}.png`;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      // Revoke after a short timeout to ensure download started
      setTimeout(() => URL.revokeObjectURL(url), 1000);
    }, 'image/png');
  } catch (err) {
    console.error('Export failed', err);
    alert('Export failed: see console for details.');
  }
});

/* -------------------------
   Palette parsing & preview
   ------------------------- */
/**
 * parsePaletteFromData
 * Convert a binary palette format (pairs of bytes) into an array of {r,g,b}.
 * Assumes words are in big-endian order in the buffer: (byte0 << 8) | byte1.
 * Bits are interpreted as 3 nibbles like the Genesis 9-bit-ish format scaled to 0-255.
 */
function parsePaletteFromData(pData) {
  if (!pData || pData.length < 2) return null;
  const entries = Math.floor(pData.length / 2);
  const palette = new Array(entries);
  for (let i = 0; i < entries; i++) {
    // Combine two bytes into a 16-bit word
    const wordValue = (pData[i * 2] << 8) | pData[i * 2 + 1];

    // Extract pseudo-nibbles for B,G,R (these masks follow the original code's intent)
    const blueNib  = (wordValue >> 8) & 0x0E;
    const greenNib = (wordValue >> 4) & 0x0E;
    const redNib   = wordValue & 0x0E;

    // Stretch nibble (0-14 step 2) to 0-255 by multiplying by 17 (approximate)
    const R = redNib   * 17;
    const G = greenNib * 17;
    const B = blueNib  * 17;

    palette[i] = { r: R, g: G, b: B };
  }
  return palette;
}

/* Show a simple row of swatches to help visually verify the loaded palette */
function showPalettePreview(palette) {
  palettePreview.innerHTML = '';
  if (!palette) return;
  const max = Math.min(palette.length, 256);
  for (let i = 0; i < max; i++) {
    const p = palette[i];
    const div = document.createElement('div');
    div.className = 'sw';
    div.title = `#${i} rgb(${p.r},${p.g},${p.b})`;
    div.style.backgroundColor = `rgb(${p.r},${p.g},${p.b})`;
    palettePreview.appendChild(div);
  }
}

/* -------------------------
   Progress display helpers
   ------------------------- */
function showProgress(show) {
  progressBar.style.display = show ? 'block' : 'none';
  progressText.style.display = show ? 'block' : 'none';
}

function updateProgress(current, total) {
  const percent = Math.round((current / total) * 100);
  progressFill.style.width = percent + '%';
  progressText.textContent = `Rendering: ${current} / ${total} stamps (${percent}%)`;
}

/* -------------------------
   Main render dispatcher
   ------------------------- */
/* Decide whether to draw a stamp map or the raw tile grid */
async function renderIfReady() {
  if (!tileData) return; // nothing to draw until we have tile data

  // Cancel any ongoing render
  if (renderingInProgress) {
    cancelRendering = true;
    // Wait a bit for the cancellation to complete
    await new Promise(resolve => setTimeout(resolve, 100));
  }

  const palette = paletteData ? parsePaletteFromData(paletteData) : null;
  showPalettePreview(palette);

  // If stamp map is present render the map; otherwise show a simple tile grid
  if (stampMapData) {
    await renderStampMap(tileData, palette, stampMapData);
  } else {
    renderTileGrid(tileData, palette);
  }
}

/* -------------------------
   Tile drawing helpers
   ------------------------- */
/**
 * drawTileOntoImageData
 * Render a single 8x8 tile (4bpp) from the packed tileData into an ImageData buffer.
 *
 * - imgData: ImageData object to modify (imgData.data is Uint8ClampedArray)
 * - tileIndex: index of the tile (0-based) in 32-byte-per-tile layout
 * - tileData: raw ArrayBuffer/Uint8Array with tile bytes
 * - palette: optional parsed palette array; if missing, uses grayscale from value
 * - targetX, targetY: destination pixel coordinates inside imgData
 */
function drawTileOntoImageData(imgData, tileIndex, tileData, palette, targetX, targetY) {
  const tileW = 8, tileH = 8;
  const bytesPerTile = 32;
  const base = tileIndex * bytesPerTile;

  // Bounds check: if tile index points beyond available bytes, skip it
  if (base + bytesPerTile > tileData.length) return;

  const imageW = imgData.width;
  const px = imgData.data;

  // Each tile is 8 rows; each row takes 4 bytes (2 pixels per byte for 4bpp)
  for (let row = 0; row < tileH; row++) {
    const rowOffset = base + row * 4; // 4 bytes per row
    for (let col = 0; col < tileW; col++) {
      const byteIndex = rowOffset + (col >> 1); // two pixels per byte
      const b = tileData[byteIndex];

      // Extract 4-bit pixel value: high nibble for even column, low nibble for odd
      const pixelVal = (col & 1) === 0 ? ((b >> 4) & 0x0F) : (b & 0x0F);

      // Default color is black (and fully transparent for palette index 0)
      let R = 0, G = 0, B = 0;

      if (pixelVal !== 0) {
        // If a palette exists and covers the index use it, otherwise compute grayscale
        if (palette && pixelVal < palette.length) {
          const pcol = palette[pixelVal];
          R = pcol.r; G = pcol.g; B = pcol.b;
        } else {
          const g = Math.round((pixelVal / 15) * 255);
          R = G = B = g;
        }
      }

      // Write to the ImageData backing buffer
      const x = targetX + col;
      const y = targetY + row;
      const di = (y * imageW + x) * 4;
      px[di] = R;
      px[di + 1] = G;
      px[di + 2] = B;
      px[di + 3] = (pixelVal === 0) ? 0 : 255; // index 0 => transparent
    }
  }
}

/* -------------------------
   Stamp map rendering (OPTIMIZED + debug hex mode + delayed batches)
   ------------------------- */
/**
 * renderStampMap
 * Interpret a stamp map file and draw stamps to the canvas progressively.
 * When "Show raw hex" debug is enabled, write the 16-bit word as hex in each cell
 * and skip flipping/rotation/tile composition.
 *
 * Bit layout enforced here:  HRR0 0SSS SSSS SSSS
 * - bit 15: H (horizontal flip)
 * - bits 14-13: RR (rotation: 00=0°, 01=90°, 10=180°, 11=270°)
 * - bits 12-11: reserved/zero
 * - bits 10-0: S (11-bit stamp ID)
 *
 * We explicitly read big-endian words and apply masks/shifts to match that format.
 */
async function renderStampMap(tileData, palette, stampMapData) {
  // Signal that we're starting a new render
  renderingInProgress = true;
  cancelRendering = false;
  
  // Map size (stamps), stamp pixel size, and how many 8x8 tiles fit in a stamp
  const [mapW, mapH] = settingMapSize.value.split('x').map(Number);
  const stampSize = parseInt(settingStampSize.value, 10);
  const tilesPerDim = stampSize / 8; // e.g., 16px => 2 tiles, 32px => 4 tiles

  // Resize canvas to exactly the stamp map size in pixels
  canvas.width = mapW * stampSize;
  canvas.height = mapH * stampSize;
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Show progress bar
  showProgress(true);

  // Debug mode: show hex values instead of composing/drawing stamps
  const debugHex = settingDebugHex.checked;

  // Create a DataView to read 16-bit words from the provided stampMapData buffer
  const mapView = new DataView(stampMapData.buffer);

  const totalStamps = mapW * mapH;
  const stampsPerBatch = 100; // process 100 stamps per batch
  const interBatchDelayMs = 250; // 0.25 second delay between batches
  let currentStamp = 0;

  // If we will compose stamps normally, prepare temporary stamp canvas
  let stampCanvas = null, stampCtx = null, stampImgData = null;
  if (!debugHex) {
    stampCanvas = document.createElement('canvas');
    stampCanvas.width = stampCanvas.height = stampSize;
    stampCtx = stampCanvas.getContext('2d');
    stampImgData = stampCtx.createImageData(stampSize, stampSize);
  }

  // Preconfigure text properties for debug mode
  if (debugHex) {
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    // Choose a font size that fits inside the stamp cell, with a minimum
    const fontSize = Math.max(8, Math.floor(stampSize / 3));
    ctx.font = `${fontSize}px monospace`;
  }

  // Masks for the HRR0 0SSS... format
  const H_MASK = 0x8000;      // bit 15
  const ROT_MASK = 0x6000;    // bits 14-13
  const STAMP_MASK = 0x07FF;  // bits 10-0

  // Process stamps in batches
  const processBatch = () => {
    if (cancelRendering) {
      showProgress(false);
      renderingInProgress = false;
      return;
    }

    const batchEnd = Math.min(currentStamp + stampsPerBatch, totalStamps);
    
    for (let i = currentStamp; i < batchEnd; i++) {
      const my = Math.floor(i / mapW);
      const mx = i % mapW;
      const mapIndex = i;

      // Each map entry is 2 bytes (Uint16). Skip if out of bounds.
      if ((mapIndex * 2 + 1) >= mapView.byteLength) continue;

      // Read word as big-endian explicitly (DataView default is big-endian, but pass false for clarity)
      const word = mapView.getUint16(mapIndex * 2, false);

      // Destination coordinates on the main canvas
      const destX = mx * stampSize;
      const destY = my * stampSize;

      if (debugHex) {
        // Draw a light background for the cell to make the text readable
        if (word === 0) {
          ctx.fillStyle = '#f5f5f5';
        } else {
          ctx.fillStyle = '#e8e8ff';
        }
        ctx.fillRect(destX, destY, stampSize, stampSize);

        // draw border
        ctx.strokeStyle = '#bbb';
        ctx.strokeRect(destX + 0.5, destY + 0.5, stampSize - 1, stampSize - 1);

        // Format hex string '0xFFFF'
        const hex = '0x' + word.toString(16).toUpperCase().padStart(4, '0');

        // Color the text darker if background is light
        ctx.fillStyle = '#111';
        ctx.fillText(hex, destX + stampSize / 2, destY + stampSize / 2);
        continue; // skip composing tiles / transforms
      }

      // Normal (non-debug) rendering path:
      // - H bit (bit15) = horizontal flip (applied AFTER rotation)
      // - RR bits (bits14-13) = rotation (00=0°, 01=90°, 10=180°, 11=270°)
      // - lower 11 bits = stamp index (1-based; 0 means blank)

      const hFlip = (word & H_MASK) !== 0;
      const rotation = (word & ROT_MASK) >> 13; // yields 0..3 matching 0/90/180/270

      // TWO-STEP: mask index first, check for zero (blank), then convert to 0-based
      const stampIndex = word & STAMP_MASK; // bits 10..0
      if (stampIndex === 0) continue;       // masked-zero -> blank cell
      let stampAddr = stampIndex - 1;       // safe to subtract now

      // For 32px stamps the address alignment may require masking off lower bits
      // (user note: last 2 bits are ignored with 32x32 stamps; keep multiples-of-4 behavior)
      if (stampSize === 32) stampAddr &= ~0x03;

      // Convert stamp address into base tile index (each stamp references multiple 8x8 tiles)
      // Historically stamps referenced 4 tiles (2x2) at 16px size; keep the same scaling logic.
      // baseTileIndex = stampAddr * (tilesPerDim * tilesPerDim) would also be correct
      // if your stamp indexing is that a stamp ID points to a block of tiles sized stampSize×stampSize.
      const baseTileIndex = stampAddr * 4;

      // Clear stamp image buffer
      stampImgData.data.fill(0);

      // Fill the stamp image by drawing each sub-tile into the stamp image buffer.
      for (let sty = 0; sty < tilesPerDim; sty++) {
        for (let stx = 0; stx < tilesPerDim; stx++) {
          const tileIndexInStamp = stx * tilesPerDim + sty;
          drawTileOntoImageData(stampImgData, baseTileIndex + tileIndexInStamp, tileData, palette, stx * 8, sty * 8);
        }
      }

      // Put the composed stamp image into the temporary canvas
      stampCtx.putImageData(stampImgData, 0, 0);

      // Destination coordinates on the main canvas (stamp center)
      const centerX = destX + stampSize / 2;
      const centerY = destY + stampSize / 2;

      // Save state, translate to stamp center, apply rotation then flip, draw, restore
      ctx.save();
      ctx.translate(centerX, centerY);

      // Sega CD rotates counter-clockwise
      ctx.rotate(-rotation * Math.PI / 2);

      // Apply flip along the stamp's logical X-axis after rotation
      // 0°/180°: flip horizontally; 90°/270°: flip vertically
      if (hFlip) {
        if (rotation % 2 === 0) {
          ctx.scale(-1, 1);
        } else {
          ctx.scale(1, -1);
        }
      }

      // Draw the stamp centered at the origin after transforms
      ctx.drawImage(stampCanvas, -stampSize / 2, -stampSize / 2);

      ctx.restore();
    }

    currentStamp = batchEnd;
    updateProgress(currentStamp, totalStamps);

    if (currentStamp < totalStamps) {
      // Delay between batches to be gentle on the browser (250 ms)
      setTimeout(() => {
        if (!cancelRendering) requestAnimationFrame(processBatch);
      }, interBatchDelayMs);
    } else {
      // Rendering complete
      showProgress(false);
      renderingInProgress = false;
    }
  };

  // Start processing
  requestAnimationFrame(processBatch);
}

/* -------------------------
   Simple tile grid renderer
   ------------------------- */
/**
 * renderTileGrid
 * Draws all tiles sequentially in a fixed-width grid (32 tiles per row).
 * Useful when no stamp map is provided: shows raw tile set layout.
 */
function renderTileGrid(data, palette) {
  const tileW = 8, tileH = 8;
  const bytesPerTile = 32;
  const tilesPerRow = 32; // fixed width for simple browsing

  const numTiles = Math.floor(data.length / bytesPerTile);
  if (numTiles === 0) {
    // Nothing to draw — ensure canvas is valid but empty
    canvas.width = 1; canvas.height = 1;
    ctx.clearRect(0,0,1,1);
    return;
  }

  // Compute full image size and create an ImageData buffer to paint into
  const imageW = tilesPerRow * tileW;
  const imageH = Math.ceil(numTiles / tilesPerRow) * tileH;
  canvas.width = imageW;
  canvas.height = imageH;
  const img = ctx.createImageData(imageW, imageH);

  // Render each tile into the big ImageData then blit once for performance
  for (let t = 0; t < numTiles; t++) {
    const tileX = (t % tilesPerRow) * tileW;
    const tileY = Math.floor(t / tilesPerRow) * tileH;
    drawTileOntoImageData(img, t, data, palette, tileX, tileY);
  }
  ctx.putImageData(img, 0, 0);
}
</script>
</body>
</html>
