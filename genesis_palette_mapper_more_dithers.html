<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Sega Genesis Palette Mapper — More Dithers (RGB Balance Added)</title>
<style>
  body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; padding: 18px; }
  .row { display:flex; gap:18px; align-items:flex-start; }
  canvas { border:1px solid #ccc; image-rendering: pixelated; }
  .palette-grid { display:grid; grid-template-columns: repeat(32, 18px); gap:2px; }
  .swatch { width:18px; height:18px; border:1px solid rgba(0,0,0,0.08); }
  .colors-list { max-height: 320px; overflow:auto; width:420px; border:1px solid #eee; padding:8px; }
  .controls { display:flex; gap:12px; align-items:center; flex-wrap:wrap; margin-bottom:12px; }
  label { display:flex; gap:6px; align-items:center; }
  input[type="number"] { width:80px; padding:6px; }
  button { padding:8px 12px; border-radius:6px; border:1px solid #bbb; background: #fafafa; cursor:pointer; }
  .stats { margin-top:8px; font-family:monospace; }
  .highlight { outline:2px solid #333; }
  .small { font-size:0.85rem; color:#444; }
  .control-group { display:flex; gap:8px; align-items:center; }
  #rgbControls { gap: 12px; align-items:center; display:none; } /* hidden by default */
</style>
</head>
<body>
<h2>Sega Genesis Palette Mapper — More Dithers</h2>
<p>Upload a sprite. New dithering options added: ordered (2x2/4x4/8x8), error-diffusion variants (Floyd, Atkinson, Jarvis, Stucki, Sierra, Burkes), and random noise.</p>

<div class="controls">
  <input id="fileInput" type="file" accept="image/*" />
  <label> Dither:
    <select id="ditherSelect">
      <option value="none">None</option>
      <optgroup label="Ordered">
        <option value="ordered_2">Ordered 2×2</option>
        <option value="ordered_4">Ordered 4×4</option>
        <option value="ordered_8">Ordered 8×8</option>
      </optgroup>
      <optgroup label="Error diffusion">
        <option value="floyd">Floyd–Steinberg</option>
        <option value="atkinson">Atkinson</option>
        <option value="jarvis">Jarvis–Judice–Ninke (JJN)</option>
        <option value="stucki">Stucki</option>
        <option value="sierra">Sierra</option>
        <option value="burkes">Burkes</option>
      </optgroup>
      <option value="random">Noise</option>
    </select>
  </label>

  <label>Limit colors:
    <input id="limitCheck" type="checkbox" />
  </label>
  <label>Max colors:
    <input id="maxColorsInput" type="number" min="2" max="512" value="32" />
  </label>

  <label> Prefer diverse colors:
    <input id="diverseCheck" type="checkbox" />
  </label>

  <!-- NEW: RGB balance controls (wrapped and hidden by default; shown only when "Prefer diverse colors" is checked) -->
  <div id="rgbControls" class="control-group">
    <label class="small">Balance by RGB:
      <input id="rgbBalanceCheck" type="checkbox" title="Bias selection away from the dominant channel (auto) or a selected channel (manual)" />
    </label>
    <label class="small">Mode:
      <select id="rgbBalanceAxis" title="Choose 'auto' to detect dominant channel, or pick a channel manually" style="padding:6px;">
        <option value="auto">Auto (detect dominant)</option>
        <option value="red">Manual: Red</option>
        <option value="green">Manual: Green</option>
        <option value="blue">Manual: Blue</option>
        <option value="none">None</option>
      </select>
    </label>
    <label class="small">Strength:
      <input id="rgbBalanceStrength" type="range" min="0" max="100" value="50" />
    </label>
  </div>

  <button id="processBtn" disabled>Process / Remap</button>
  <button id="downloadBtn" disabled>Download Remapped Image</button>
</div>

<div class="stats" id="statsArea">
  Original unique colors: <span id="origCount">0</span> &nbsp; | &nbsp;
  Processed unique colors: <span id="procCount">0</span> &nbsp; | &nbsp;
  Palette colors allowed: <span id="allowedCount">512</span>
</div>

<div class="row" style="margin-top:12px;">
  <div>
    <h4>Original</h4>
    <canvas id="origCanvas"></canvas>
  </div>
  <div>
    <h4>Processed</h4>
    <canvas id="outCanvas"></canvas>
  </div>
  <div style="min-width:420px;">
    <h4>Colors found (top first)</h4>
    <div id="colorsList" class="colors-list"></div>
  </div>
</div>

<h4>512-color Genesis Palette (allowed will be highlighted)</h4>
<div id="paletteGrid" class="palette-grid"></div>

<script>
// Embedded palette (512 hex colors)
const PALETTE = [
  "#000000",
  "#000048",
  "#000090",
  "#0000d8",
  "#200000",
  "#200048",
  "#200090",
  "#2000d8",
  "#480000",
  "#480048",
  "#480090",
  "#4800d8",
  "#680000",
  "#680048",
  "#680090",
  "#6800d8",
  "#900000",
  "#900048",
  "#900090",
  "#9000d8",
  "#b00000",
  "#b00048",
  "#b00090",
  "#b000d8",
  "#d80000",
  "#d80048",
  "#d80090",
  "#d800d8",
  "#f80000",
  "#f80048",
  "#f80090",
  "#f800d8",
  "#002400",
  "#002448",
  "#002490",
  "#0024d8",
  "#202400",
  "#202448",
  "#202490",
  "#2024d8",
  "#482400",
  "#482448",
  "#482490",
  "#4824d8",
  "#682400",
  "#682448",
  "#682490",
  "#6824d8",
  "#902400",
  "#902448",
  "#902490",
  "#9024d8",
  "#b02400",
  "#b02448",
  "#b02490",
  "#b024d8",
  "#d82400",
  "#d82448",
  "#d82490",
  "#d824d8",
  "#f82400",
  "#f82448",
  "#f82490",
  "#f824d8",
  "#004800",
  "#004848",
  "#004890",
  "#0048d8",
  "#204800",
  "#204848",
  "#204890",
  "#2048d8",
  "#484800",
  "#484848",
  "#484890",
  "#4848d8",
  "#684800",
  "#684848",
  "#684890",
  "#6848d8",
  "#904800",
  "#904848",
  "#904890",
  "#9048d8",
  "#b04800",
  "#b04848",
  "#b04890",
  "#b048d8",
  "#d84800",
  "#d84848",
  "#d84890",
  "#d848d8",
  "#f84800",
  "#f84848",
  "#f84890",
  "#f848d8",
  "#006c00",
  "#006c48",
  "#006c90",
  "#006cd8",
  "#206c00",
  "#206c48",
  "#206c90",
  "#206cd8",
  "#486c00",
  "#486c48",
  "#486c90",
  "#486cd8",
  "#686c00",
  "#686c48",
  "#686c90",
  "#686cd8",
  "#906c00",
  "#906c48",
  "#906c90",
  "#906cd8",
  "#b06c00",
  "#b06c48",
  "#b06c90",
  "#b06cd8",
  "#d86c00",
  "#d86c48",
  "#d86c90",
  "#d86cd8",
  "#f86c00",
  "#f86c48",
  "#f86c90",
  "#f86cd8",
  "#009000",
  "#009048",
  "#009090",
  "#0090d8",
  "#209000",
  "#209048",
  "#209090",
  "#2090d8",
  "#489000",
  "#489048",
  "#489090",
  "#4890d8",
  "#689000",
  "#689048",
  "#689090",
  "#6890d8",
  "#909000",
  "#909048",
  "#909090",
  "#9090d8",
  "#b09000",
  "#b09048",
  "#b09090",
  "#b090d8",
  "#d89000",
  "#d89048",
  "#d89090",
  "#d890d8",
  "#f89000",
  "#f89048",
  "#f89090",
  "#f890d8",
  "#00b400",
  "#00b448",
  "#00b490",
  "#00b4d8",
  "#20b400",
  "#20b448",
  "#20b490",
  "#20b4d8",
  "#48b400",
  "#48b448",
  "#48b490",
  "#48b4d8",
  "#68b400",
  "#68b448",
  "#68b490",
  "#68b4d8",
  "#90b400",
  "#90b448",
  "#90b490",
  "#90b4d8",
  "#b0b400",
  "#b0b448",
  "#b0b490",
  "#b0b4d8",
  "#d8b400",
  "#d8b448",
  "#d8b490",
  "#d8b4d8",
  "#f8b400",
  "#f8b448",
  "#f8b490",
  "#f8b4d8",
  "#00d800",
  "#00d848",
  "#00d890",
  "#00d8d8",
  "#20d800",
  "#20d848",
  "#20d890",
  "#20d8d8",
  "#48d800",
  "#48d848",
  "#48d890",
  "#48d8d8",
  "#68d800",
  "#68d848",
  "#68d890",
  "#68d8d8",
  "#90d800",
  "#90d848",
  "#90d890",
  "#90d8d8",
  "#b0d800",
  "#b0d848",
  "#b0d890",
  "#b0d8d8",
  "#d8d800",
  "#d8d848",
  "#d8d890",
  "#d8d8d8",
  "#f8d800",
  "#f8d848",
  "#f8d890",
  "#f8d8d8",
  "#00fc00",
  "#00fc48",
  "#00fc90",
  "#00fcd8",
  "#20fc00",
  "#20fc48",
  "#20fc90",
  "#20fcd8",
  "#48fc00",
  "#48fc48",
  "#48fc90",
  "#48fcd8",
  "#68fc00",
  "#68fc48",
  "#68fc90",
  "#68fcd8",
  "#90fc00",
  "#90fc48",
  "#90fc90",
  "#90fcd8",
  "#b0fc00",
  "#b0fc48",
  "#b0fc90",
  "#b0fcd8",
  "#d8fc00",
  "#d8fc48",
  "#d8fc90",
  "#d8fcd8",
  "#f8fc00",
  "#f8fc48",
  "#f8fc90",
  "#f8fcd8",
  "#000020",
  "#000068",
  "#0000b0",
  "#0000f8",
  "#200020",
  "#200068",
  "#2000b0",
  "#2000f8",
  "#480020",
  "#480068",
  "#4800b0",
  "#4800f8",
  "#680020",
  "#680068",
  "#6800b0",
  "#6800f8",
  "#900020",
  "#900068",
  "#9000b0",
  "#9000f8",
  "#b00020",
  "#b00068",
  "#b000b0",
  "#b000f8",
  "#d80020",
  "#d80068",
  "#d800b0",
  "#d800f8",
  "#f80020",
  "#f80068",
  "#f800b0",
  "#f800f8",
  "#002420",
  "#002468",
  "#0024b0",
  "#0024f8",
  "#202420",
  "#202468",
  "#2024b0",
  "#2024f8",
  "#482420",
  "#482468",
  "#4824b0",
  "#4824f8",
  "#682420",
  "#682468",
  "#6824b0",
  "#6824f8",
  "#902420",
  "#902468",
  "#9024b0",
  "#9024f8",
  "#b02420",
  "#b02468",
  "#b024b0",
  "#b024f8",
  "#d82420",
  "#d82468",
  "#d824b0",
  "#d824f8",
  "#f82420",
  "#f82468",
  "#f824b0",
  "#f824f8",
  "#004820",
  "#004868",
  "#0048b0",
  "#0048f8",
  "#204820",
  "#204868",
  "#2048b0",
  "#2048f8",
  "#484820",
  "#484868",
  "#4848b0",
  "#4848f8",
  "#684820",
  "#684868",
  "#6848b0",
  "#6848f8",
  "#904820",
  "#904868",
  "#9048b0",
  "#9048f8",
  "#b04820",
  "#b04868",
  "#b048b0",
  "#b048f8",
  "#d84820",
  "#d84868",
  "#d848b0",
  "#d848f8",
  "#f84820",
  "#f84868",
  "#f848b0",
  "#f848f8",
  "#006c20",
  "#006c68",
  "#006cb0",
  "#006cf8",
  "#206c20",
  "#206c68",
  "#206cb0",
  "#206cf8",
  "#486c20",
  "#486c68",
  "#486cb0",
  "#486cf8",
  "#686c20",
  "#686c68",
  "#686cb0",
  "#686cf8",
  "#906c20",
  "#906c68",
  "#906cb0",
  "#906cf8",
  "#b06c20",
  "#b06c68",
  "#b06cb0",
  "#b06cf8",
  "#d86c20",
  "#d86c68",
  "#d86cb0",
  "#d86cf8",
  "#f86c20",
  "#f86c68",
  "#f86cb0",
  "#f86cf8",
  "#009020",
  "#009068",
  "#0090b0",
  "#0090f8",
  "#209020",
  "#209068",
  "#2090b0",
  "#2090f8",
  "#489020",
  "#489068",
  "#4890b0",
  "#4890f8",
  "#689020",
  "#689068",
  "#6890b0",
  "#6890f8",
  "#909020",
  "#909068",
  "#9090b0",
  "#9090f8",
  "#b09020",
  "#b09068",
  "#b090b0",
  "#b090f8",
  "#d89020",
  "#d89068",
  "#d890b0",
  "#d890f8",
  "#f89020",
  "#f89068",
  "#f890b0",
  "#f890f8",
  "#00b420",
  "#00b468",
  "#00b4b0",
  "#00b4f8",
  "#20b420",
  "#20b468",
  "#20b4b0",
  "#20b4f8",
  "#48b420",
  "#48b468",
  "#48b4b0",
  "#48b4f8",
  "#68b420",
  "#68b468",
  "#68b4b0",
  "#68b4f8",
  "#90b420",
  "#90b468",
  "#90b4b0",
  "#90b4f8",
  "#b0b420",
  "#b0b468",
  "#b0b4b0",
  "#b0b4f8",
  "#d8b420",
  "#d8b468",
  "#d8b4b0",
  "#d8b4f8",
  "#f8b420",
  "#f8b468",
  "#f8b4b0",
  "#f8b4f8",
  "#00d820",
  "#00d868",
  "#00d8b0",
  "#00d8f8",
  "#20d820",
  "#20d868",
  "#20d8b0",
  "#20d8f8",
  "#48d820",
  "#48d868",
  "#48d8b0",
  "#48d8f8",
  "#68d820",
  "#68d868",
  "#68d8b0",
  "#68d8f8",
  "#90d820",
  "#90d868",
  "#90d8b0",
  "#90d8f8",
  "#b0d820",
  "#b0d868",
  "#b0d8b0",
  "#b0d8f8",
  "#d8d820",
  "#d8d868",
  "#d8d8b0",
  "#d8d8f8",
  "#f8d820",
  "#f8d868",
  "#f8d8b0",
  "#f8d8f8",
  "#00fc20",
  "#00fc68",
  "#00fcb0",
  "#00fcf8",
  "#20fc20",
  "#20fc68",
  "#20fcb0",
  "#20fcf8",
  "#48fc20",
  "#48fc68",
  "#48fcb0",
  "#48fcf8",
  "#68fc20",
  "#68fc68",
  "#68fcb0",
  "#68fcf8",
  "#90fc20",
  "#90fc68",
  "#90fcb0",
  "#90fcf8",
  "#b0fc20",
  "#b0fc68",
  "#b0fcb0",
  "#b0fcf8",
  "#d8fc20",
  "#d8fc68",
  "#d8fcb0",
  "#d8fcf8",
  "#f8fc20",
  "#f8fc68",
  "#f8fcb0",
  "#f8fcf8"
];

function hexToRgb(hex) {
  const m = hex.replace('#','');
  return [parseInt(m.substring(0,2),16), parseInt(m.substring(2,4),16), parseInt(m.substring(4,6),16)];
}
const PALETTE_RGB = PALETTE.map(hexToRgb);

const fileInput = document.getElementById('fileInput');
const processBtn = document.getElementById('processBtn');
const downloadBtn = document.getElementById('downloadBtn');
const ditherSelect = document.getElementById('ditherSelect');
const limitCheck = document.getElementById('limitCheck');
const maxColorsInput = document.getElementById('maxColorsInput');
const diverseCheck = document.getElementById('diverseCheck');
const rgbControlsDiv = document.getElementById('rgbControls');
const rgbBalanceCheck = document.getElementById('rgbBalanceCheck');
const rgbBalanceAxis = document.getElementById('rgbBalanceAxis');
const rgbBalanceStrength = document.getElementById('rgbBalanceStrength');
const origCanvas = document.getElementById('origCanvas');
const outCanvas = document.getElementById('outCanvas');
const colorsListDiv = document.getElementById('colorsList');
const origCountSpan = document.getElementById('origCount');
const procCountSpan = document.getElementById('procCount');
const allowedCountSpan = document.getElementById('allowedCount');
const paletteGrid = document.getElementById('paletteGrid');

PALETTE.forEach(h => {
  const d = document.createElement('div');
  d.className = 'swatch';
  d.title = h;
  d.style.background = h;
  paletteGrid.appendChild(d);
});

let currentImage = null;
let currentImageName = 'sprite';
let latestMapping = null;

function colorKey(r,g,b) {
  return '#' + [r,g,b].map(x => x.toString(16).padStart(2,'0')).join('');
}

function findNearestInList(r,g,b, listRGB) {
  let bestIdx = 0;
  let bestDist = Infinity;
  for (let i=0;i<listRGB.length;i++) {
    const p = listRGB[i];
    const dr = p[0]-r, dg = p[1]-g, db = p[2]-b;
    const dist = dr*dr + dg*dg + db*db;
    if (dist < bestDist) {
      bestDist = dist; bestIdx = i;
    }
  }
  return bestIdx;
}

function buildHistogram(imgData) {
  const data = imgData.data;
  const counts = new Map();
  for (let i=0;i<data.length;i+=4) {
    const a = data[i+3];
    if (a === 0) continue;
    const r = data[i], g = data[i+1], b = data[i+2];
    const key = colorKey(r,g,b);
    counts.set(key, (counts.get(key)||0) + 1);
  }
  return counts;
}

// Choose allowed palette indices (diversity option included)
// NEW: rgbBalanceMode: 'none'|'auto'|'red'|'green'|'blue' ; rgbBalanceStrength: 0..1
function chooseAllowedPaletteIndices(countsMap, maxAllowed, preferDiverse, rgbBalanceMode='none', rgbBalanceStrength=0.5) {
  const freqPerPaletteIdx = new Map();
  for (const [hex, cnt] of countsMap.entries()) {
    const rgb = hexToRgb(hex);
    const idx = findNearestInList(rgb[0], rgb[1], rgb[2], PALETTE_RGB);
    freqPerPaletteIdx.set(idx, (freqPerPaletteIdx.get(idx)||0)+cnt);
  }
  const candidates = Array.from(new Set(Array.from(freqPerPaletteIdx.keys())));
  if (candidates.length === 0) {
    for (let i=0;i<PALETTE.length;i++) candidates.push(i);
  }
  if (!preferDiverse) {
    const sorted = Array.from(freqPerPaletteIdx.entries()).sort((a,b)=>b[1]-a[1]);
    const chosen = sorted.slice(0, maxAllowed).map(x=>x[0]);
    if (chosen.length < maxAllowed) {
      for (let i=0;i<PALETTE.length && chosen.length<maxAllowed;i++) {
        if (!chosen.includes(i)) chosen.push(i);
      }
    }
    return chosen;
  }

  // Diversity-aware greedy selection (with optional RGB-balance)
  const freqArr = {};
  let maxFreq = 0;
  for (const idx of candidates) {
    const f = freqPerPaletteIdx.get(idx) || 0;
    freqArr[idx] = f;
    if (f > maxFreq) maxFreq = f;
  }
  const freqNorm = {};
  for (const idx of candidates) {
    freqNorm[idx] = maxFreq === 0 ? 0 : (freqArr[idx] / maxFreq);
  }

  const maxPossibleDist = 255*255*3;
  const distCache = {};
  for (let i=0;i<PALETTE_RGB.length;i++) {
    distCache[i] = {};
  }
  for (let i=0;i<PALETTE_RGB.length;i++) {
    for (let j=0;j<PALETTE_RGB.length;j++) {
      const a = PALETTE_RGB[i], b = PALETTE_RGB[j];
      const dr = a[0]-b[0], dg = a[1]-b[1], db = a[2]-b[2];
      distCache[i][j] = dr*dr + dg*dg + db*db;
    }
  }

  // If rgbBalanceMode is 'auto', compute dominant channel across the image
  let balanceChannel = null; // 0=r,1=g,2=b
  if (rgbBalanceMode === 'auto') {
    let sumR = 0, sumG = 0, sumB = 0;
    for (const [hex, cnt] of countsMap.entries()) {
      const [r,g,b] = hexToRgb(hex);
      sumR += r * cnt;
      sumG += g * cnt;
      sumB += b * cnt;
    }
    if (sumR >= sumG && sumR >= sumB) balanceChannel = 0;
    else if (sumG >= sumR && sumG >= sumB) balanceChannel = 1;
    else balanceChannel = 2;
  } else if (rgbBalanceMode === 'red') balanceChannel = 0;
  else if (rgbBalanceMode === 'green') balanceChannel = 1;
  else if (rgbBalanceMode === 'blue') balanceChannel = 2;
  else balanceChannel = null;

  // Normalize strength 0..1
  const strength = Math.max(0, Math.min(1, Number(rgbBalanceStrength) || 0));

  const chosen = [];
  candidates.sort((a,b)=> (freqArr[b] - freqArr[a]));
  chosen.push(candidates[0]);

  while (chosen.length < maxAllowed) {
    let bestIdx = null;
    let bestScore = -Infinity;
    for (const idx of candidates) {
      if (chosen.includes(idx)) continue;
      let minDist = Infinity;
      for (const c of chosen) {
        const d = distCache[idx][c];
        if (d < minDist) minDist = d;
      }
      if (minDist === Infinity) minDist = 0;
      const distScore = minDist / maxPossibleDist;
      const freqScore = freqNorm[idx] || 0;
      let baseScore = 0.6*freqScore + 0.4*distScore;

      // Apply RGB balance bias away from dominant channel: colors with LOWER value in the dominant channel get a bonus.
      if (balanceChannel !== null && strength > 0) {
        const channelValue = PALETTE_RGB[idx][balanceChannel] / 255; // 0..1
        const balanceScore = 1 - channelValue; // higher when palette color has less of the dominant channel
        // center around 0: (balanceScore - 0.5) in [-0.5,0.5]
        // combine with strength but damp so doesn't fully override other heuristics
        baseScore = baseScore + (strength * 0.8) * (balanceScore - 0.5);
      }

      const score = baseScore;
      if (score > bestScore) {
        bestScore = score;
        bestIdx = idx;
      }
    }
    if (bestIdx === null) break;
    chosen.push(bestIdx);
    if (chosen.length === candidates.length) break;
  }

  if (chosen.length < maxAllowed) {
    for (let i=0;i<PALETTE.length && chosen.length<maxAllowed;i++) {
      if (!chosen.includes(i)) chosen.push(i);
    }
  }

  return chosen.slice(0, maxAllowed);
}

// Ordered dither matrices
const bayer2 = [[0,2],[3,1]];
const bayer4 = [[0,8,2,10],[12,4,14,6],[3,11,1,9],[15,7,13,5]];
const bayer8 = [
  [0,32,8,40,2,34,10,42],
  [48,16,56,24,50,18,58,26],
  [12,44,4,36,14,46,6,38],
  [60,28,52,20,62,30,54,22],
  [3,35,11,43,1,33,9,41],
  [51,19,59,27,49,17,57,25],
  [15,47,7,39,13,45,5,37],
  [61,29,55,23,61,29,53,21] // small tweak; consistent matrix
];

function applyOrdered(imgData, allowedIdxs, matrix) {
  const width = imgData.width, height = imgData.height;
  const data = imgData.data;
  const allowedRGB = allowedIdxs.map(i=>PALETTE_RGB[i]);
  const n = matrix.length;
  const denom = n*n;
  for (let y=0;y<height;y++) {
    for (let x=0;x<width;x++) {
      const i = (y*width + x)*4;
      const a = data[i+3];
      if (a === 0) continue;
      const thresh = (matrix[y % n][x % n] + 0.5)/denom - 0.5;
      let r = data[i], g = data[i+1], b = data[i+2];
      r = Math.max(0, Math.min(255, Math.round(r + thresh*16)));
      g = Math.max(0, Math.min(255, Math.round(g + thresh*16)));
      b = Math.max(0, Math.min(255, Math.round(b + thresh*16)));
      const idx = findNearestInList(r,g,b, allowedRGB);
      const pal = allowedRGB[idx];
      data[i] = pal[0]; data[i+1] = pal[1]; data[i+2] = pal[2];
    }
  }
  return imgData;
}

// General error-diffusion with kernel
function applyErrorDiffusion(imgData, allowedIdxs, kernel) {
  const width = imgData.width, height = imgData.height;
  const data = imgData.data;
  const allowedRGB = allowedIdxs.map(i=>PALETTE_RGB[i]);
  const buf = new Float32Array(data.length);
  for (let i=0;i<data.length;i++) buf[i] = data[i];
  for (let y=0;y<height;y++) {
    for (let x=0;x<width;x++) {
      const idx = (y*width + x)*4;
      const a = buf[idx+3];
      if (a === 0) continue;
      const oldR = buf[idx], oldG = buf[idx+1], oldB = buf[idx+2];
      const nearestIdx = findNearestInList(oldR, oldG, oldB, allowedRGB);
      const pal = allowedRGB[nearestIdx];
      buf[idx] = pal[0]; buf[idx+1] = pal[1]; buf[idx+2] = pal[2];
      const errR = oldR - pal[0];
      const errG = oldG - pal[1];
      const errB = oldB - pal[2];
      for (const k of kernel) {
        const nx = x + k.x, ny = y + k.y;
        if (nx < 0 || nx >= width || ny < 0 || ny >= height) continue;
        const nidx = (ny*width + nx)*4;
        buf[nidx]   = buf[nidx]   + errR * k.w;
        buf[nidx+1] = buf[nidx+1] + errG * k.w;
        buf[nidx+2] = buf[nidx+2] + errB * k.w;
      }
    }
  }
  for (let i=0;i<data.length;i++) {
    if (i%4===3) data[i] = buf[i]; else data[i] = Math.max(0, Math.min(255, Math.round(buf[i])));
  }
  return imgData;
}

// Define kernels (weights sum to 1 in distribution)
const KERNELS = {
  'floyd': [
    {x:1,y:0,w:7/16}, {x:-1,y:1,w:3/16}, {x:0,y:1,w:5/16}, {x:1,y:1,w:1/16}
  ],
  'burkes': [
    {x:1,y:0,w:8/32}, {x:2,y:0,w:4/32},
    {x:-2,y:1,w:2/32}, {x:-1,y:1,w:4/32}, {x:0,y:1,w:8/32}, {x:1,y:1,w:4/32}, {x:2,y:1,w:2/32}
  ],
  'jarvis': [
    {x:1,y:0,w:7/48}, {x:2,y:0,w:5/48},
    {x:-2,y:1,w:3/48},{x:-1,y:1,w:5/48},{x:0,y:1,w:7/48},{x:1,y:1,w:5/48},{x:2,y:1,w:3/48},
    {x:-2,y:2,w:1/48},{x:-1,y:2,w:3/48},{x:0,y:2,w:5/48},{x:1,y:2,w:3/48},{x:2,y:2,w:1/48}
  ],
  'sierra': [
    {x:1,y:0,w:5/32}, {x:2,y:0,w:3/32},
    {x:-2,y:1,w:2/32},{x:-1,y:1,w:4/32},{x:0,y:1,w:5/32},{x:1,y:1,w:4/32},{x:2,y:1,w:2/32},
    {x:-1,y:2,w:2/32},{x:0,y:2,w:3/32},{x:1,y:2,w:2/32}
  ],
  'stucki': [
    {x:1,y:0,w:8/42},{x:2,y:0,w:4/42},
    {x:-2,y:1,w:2/42},{x:-1,y:1,w:4/42},{x:0,y:1,w:8/42},{x:1,y:1,w:4/42},{x:2,y:1,w:2/42},
    {x:-2,y:2,w:1/42},{x:-1,y:2,w:2/42},{x:0,y:2,w:4/42},{x:1,y:2,w:2/42},{x:2,y:2,w:1/42}
  ],
  'atkinson': [
    {x:1,y:0,w:1/8},{x:2,y:0,w:1/8},
    {x:-1,y:1,w:1/8},{x:0,y:1,w:1/8},{x:1,y:1,w:1/8},
    {x:0,y:2,w:1/8}
  ]
};

function applyRandomNoise(imgData, allowedIdxs) {
  const data = imgData.data;
  const allowedRGB = allowedIdxs.map(i=>PALETTE_RGB[i]);
  for (let i=0;i<data.length;i+=4) {
    const a = data[i+3];
    if (a === 0) continue;
    const r = Math.max(0, Math.min(255, Math.round(data[i] + (Math.random()-0.5)*32)));
    const g = Math.max(0, Math.min(255, Math.round(data[i+1] + (Math.random()-0.5)*32)));
    const b = Math.max(0, Math.min(255, Math.round(data[i+2] + (Math.random()-0.5)*32)));
    const idx = findNearestInList(r,g,b, allowedRGB);
    const pal = allowedRGB[idx];
    data[i] = pal[0]; data[i+1] = pal[1]; data[i+2] = pal[2];
  }
  return imgData;
}

function mapWithoutDither(imgData, allowedIdxs) {
  const data = imgData.data;
  const allowedRGB = allowedIdxs.map(i=>PALETTE_RGB[i]);
  for (let i=0;i<data.length;i+=4) {
    const a = data[i+3];
    if (a === 0) continue;
    const r = data[i], g = data[i+1], b = data[i+2];
    const idx = findNearestInList(r,g,b, allowedRGB);
    const pal = allowedRGB[idx];
    data[i] = pal[0]; data[i+1] = pal[1]; data[i+2] = pal[2];
  }
  return imgData;
}

function countUniqueColors(imgData) {
  const data = imgData.data;
  const s = new Set();
  for (let i=0;i<data.length;i+=4) {
    const a = data[i+3];
    if (a === 0) continue;
    s.add(colorKey(data[i], data[i+1], data[i+2]));
  }
  return s.size;
}

function highlightAllowed(allowedIdxs) {
  Array.from(paletteGrid.children).forEach((el, i) => {
    el.classList.toggle('highlight', allowedIdxs.includes(i));
  });
}

function updateColorsList(countsMap, mappingToPalette) {
  colorsListDiv.innerHTML = '';
  const items = Array.from(countsMap.entries()).sort((a,b)=>b[1]-a[1]);
  const limitShow = 300;
  for (let i=0;i<Math.min(items.length, limitShow); i++) {
    const [hex, cnt] = items[i];
    const mapped = mappingToPalette.get(hex);
    const row = document.createElement('div');
    row.style.display='flex'; row.style.alignItems='center'; row.style.gap='8px'; row.style.marginBottom='6px';
    row.innerHTML = `
      <div style="width:24px;height:24px;border:1px solid #ccc;background:${hex}"></div>
      <div style="min-width:72px;font-family:monospace">${hex}</div>
      <div style="min-width:60px">x${cnt}</div>
      <div style="width:24px;height:24px;border:1px solid #ccc;background:${mapped.hex}"></div>
      <div style="font-family:monospace">${mapped.hex}</div>
      <div style="flex:1;text-align:right">palette idx: ${mapped.idx}</div>
    `;
    colorsListDiv.appendChild(row);
  }
  if (items.length > limitShow) {
    const more = document.createElement('div');
    more.textContent = `... and ${items.length - limitShow} more unique colors (not shown)`;
    colorsListDiv.appendChild(more);
  }
}

function processCurrentImage() {
  if (!currentImage) return;
  const img = currentImage;
  origCanvas.width = img.width; origCanvas.height = img.height;
  outCanvas.width = img.width; outCanvas.height = img.height;
  const octx = origCanvas.getContext('2d');
  const actx = outCanvas.getContext('2d');
  octx.clearRect(0,0,origCanvas.width, origCanvas.height);
  octx.drawImage(img,0,0);
  actx.clearRect(0,0,outCanvas.width, outCanvas.height);
  actx.drawImage(img,0,0);

  const imgData = octx.getImageData(0,0,origCanvas.width, origCanvas.height);
  const counts = buildHistogram(imgData);
  origCountSpan.textContent = counts.size;

  let allowedIdxs = [...Array(PALETTE.length).keys()];
  if (limitCheck.checked) {
    const maxC = Math.max(2, Math.min(512, parseInt(maxColorsInput.value) || 32));
    const preferDiverse = !!diverseCheck.checked;
    const rgbBalanceEnabled = !!rgbBalanceCheck.checked && preferDiverse; // only honor if diverse enabled
    const rgbMode = rgbBalanceEnabled ? (rgbBalanceAxis.value || 'auto') : 'none';
    const rgbStrength = rgbBalanceEnabled ? (parseInt(rgbBalanceStrength.value || 50)/100.0) : 0.0;
    allowedIdxs = chooseAllowedPaletteIndices(counts, maxC, preferDiverse, rgbMode, rgbStrength);
    allowedCountSpan.textContent = allowedIdxs.length;
  } else {
    allowedCountSpan.textContent = PALETTE.length;
  }
  highlightAllowed(allowedIdxs);

  const mappingToPalette = new Map();
  for (const [hex, cnt] of counts.entries()) {
    const rgb = hexToRgb(hex);
    const allowedRGB = allowedIdxs.map(i=>PALETTE_RGB[i]);
    const nearestRelIdx = findNearestInList(rgb[0], rgb[1], rgb[2], allowedRGB);
    const palIdx = allowedIdxs[nearestRelIdx];
    mappingToPalette.set(hex, { hex: PALETTE[palIdx], idx: palIdx });
  }

  let outImageData = octx.getImageData(0,0,origCanvas.width, origCanvas.height);
  const dither = ditherSelect.value;
  if (dither === 'none') {
    outImageData = mapWithoutDither(outImageData, allowedIdxs);
  } else if (dither === 'ordered_2') {
    outImageData = applyOrdered(outImageData, allowedIdxs, bayer2);
  } else if (dither === 'ordered_4') {
    outImageData = applyOrdered(outImageData, allowedIdxs, bayer4);
  } else if (dither === 'ordered_8') {
    outImageData = applyOrdered(outImageData, allowedIdxs, bayer8);
  } else if (dither === 'random') {
    outImageData = applyRandomNoise(outImageData, allowedIdxs);
  } else if (dither === 'atkinson') {
    outImageData = applyErrorDiffusion(outImageData, allowedIdxs, KERNELS.atkinson);
  } else if (dither === 'burkes') {
    outImageData = applyErrorDiffusion(outImageData, allowedIdxs, KERNELS.burkes);
  } else if (dither === 'jarvis') {
    outImageData = applyErrorDiffusion(outImageData, allowedIdxs, KERNELS.jarvis);
  } else if (dither === 'stucki') {
    outImageData = applyErrorDiffusion(outImageData, allowedIdxs, KERNELS.stucki);
  } else if (dither === 'sierra') {
    outImageData = applyErrorDiffusion(outImageData, allowedIdxs, KERNELS.sierra);
  } else if (dither === 'floyd') {
    outImageData = applyErrorDiffusion(outImageData, allowedIdxs, KERNELS.floyd);
  } else {
    outImageData = mapWithoutDither(outImageData, allowedIdxs);
  }
  actx.putImageData(outImageData, 0, 0);

  const procUnique = countUniqueColors(outImageData);
  procCountSpan.textContent = procUnique;

  updateColorsList(counts, mappingToPalette);
  latestMapping = outImageData;
  downloadBtn.disabled = false;
}

fileInput.addEventListener('change', async (e) => {
  const file = e.target.files && e.target.files[0];
  if (!file) return;
  currentImageName = file.name.replace(/\.[^/.]+$/, "") || 'sprite';
  const img = new Image();
  img.src = URL.createObjectURL(file);
  await img.decode();
  currentImage = img;
  processBtn.disabled = false;
  processCurrentImage();
});

processBtn.addEventListener('click', () => {
  processCurrentImage();
});

downloadBtn.addEventListener('click', () => {
  if (!latestMapping) return;
  const link = document.createElement('a');
  link.download = currentImageName + '_genesis.png';
  const c = document.createElement('canvas');
  c.width = outCanvas.width; c.height = outCanvas.height;
  const cx = c.getContext('2d');
  cx.putImageData(latestMapping, 0, 0);
  link.href = c.toDataURL('image/png');
  link.click();
});

// Show/hide + enable/disable RGB controls based on the "Prefer diverse colors" checkbox
function updateRgbControlsVisibility() {
  const show = !!diverseCheck.checked;
  rgbControlsDiv.style.display = show ? 'flex' : 'none';
  // disable controls when hidden to avoid them influencing processing accidentally
  rgbBalanceCheck.disabled = !show;
  rgbBalanceAxis.disabled = !show;
  rgbBalanceStrength.disabled = !show;
}

// Add listeners to keep UI reactive; processing re-runs when relevant controls change
[ditherSelect, limitCheck, maxColorsInput, diverseCheck, rgbBalanceCheck, rgbBalanceAxis, rgbBalanceStrength].forEach(el => {
  el.addEventListener('change', () => {
    updateRgbControlsVisibility();
    if (!currentImage) return;
    processCurrentImage();
  });
});

// initialize UI defaults
rgbBalanceAxis.value = 'auto';
updateRgbControlsVisibility();

</script>
</body>
</html>
