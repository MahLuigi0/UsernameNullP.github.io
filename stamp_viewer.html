<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Cloud Stamp Viewer</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; padding: 18px; }
    .controls { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    label { font-size:13px; }
    canvas { border:1px solid #ccc; image-rendering: pixelated; margin-top:12px; }
    .note { color:#555; font-size:13px; }
  </style>
</head>
<body>
  <h2>Cloud Stamp Viewer (HTML + JS)</h2>
  <div class="controls">
    <label>Stamps file <input id="stampsFile" type="file" accept="*/*"></label>
    <label>Stamp map file <input id="mapFile" type="file" accept="*/*"></label>
    <label>Palette file <input id="paletteFile" type="file" accept=".bin,.pal,*/*"></label>
    <label>Stamp size
      <select id="stampSize"><option value="32" selected>32×32</option><option value="16">16×16</option></select>
    </label>
    <label>Palette
      <select id="palette">
        <option value="genesis">Genesis-style (default)</option>
        <option value="grayscale">Grayscale</option>
        <option value="cloud">Cloudy (blue)</option>
        <option value="custom">Custom (uploaded)</option>
      </select>
    </label>
    <label>Scale
      <select id="scale"><option>1</option><option selected>2</option><option>3</option><option>4</option><option>6</option></select>
    </label>
    <button id="renderBtn">Render</button>
    <button id="exportPng">Export PNG</button>
  </div>

  <div class="note">Instructions: select the two uncompressed files and an optional palette file and click <b>Render</b>. The viewer accepts 16-bit-per-color palette files (common Genesis/MD .bin/.pal), little-endian. If the parser detects zero or suspicious colors it will try the other endianness automatically.</div>

  <canvas id="view" width="256" height="256"></canvas>

  <script>
(function(){
  const stampsFileInput = document.getElementById('stampsFile');
  const mapFileInput = document.getElementById('mapFile');
  const paletteFileInput = document.getElementById('paletteFile');
  const stampSizeSelect = document.getElementById('stampSize');
  const renderBtn = document.getElementById('renderBtn');
  const exportBtn = document.getElementById('exportPng');
  const scaleSelect = document.getElementById('scale');
  const paletteSelect = document.getElementById('palette');
  const canvas = document.getElementById('view');
  const ctx = canvas.getContext('2d');

  let uploadedPalette = null; // holds parsed 16-entry RGBA palette if uploaded

  async function readFile(fileInput){
    const f = fileInput.files && fileInput.files[0];
    if(!f) return null;
    return await f.arrayBuffer();
  }

  function defaultPal(name){
    if(name==='custom' && uploadedPalette) return uploadedPalette;
    if(name==='grayscale'){
      const p=[]; p.push([0,0,0,0]); for(let i=1;i<16;i++){ const v = Math.round(255*i/15); p.push([v,v,v,255]); } return p;
    }
    if(name==='cloud'){
      const p=[[0,0,0,0]];
      for(let i=1;i<16;i++){ const t = i/15; const r = Math.round(180 + 40*t); const g = Math.round(200 + 20*t); const b = Math.round(220 + 10*t); p.push([r,g,b,255]); }
      return p;
    }
    // genesis-like palette (approx)
    const base = [
      [0,0,0,0],[17,17,17,255],[45,45,45,255],[87,87,87,255],[141,141,170,255],[108,140,196,255],[84,152,208,255],[176,200,232,255],
      [120,100,80,255],[200,180,140,255],[240,200,180,255],[255,230,200,255],[120,200,120,255],[80,160,80,255],[40,120,40,255],[20,80,20,255]
    ];
    return base;
  }

  // parse 16-bit per color palette file (Sega Genesis format)
  function parsePaletteFile(buf){
    const paletteData = new Uint8Array(buf);
    const numColors = Math.min(16, paletteData.length / 2);
    const out = [];
    
    for(let i = 0; i < numColors; i++){
      // Read big-endian 16-bit word
      const wordValue = (paletteData[i * 2] << 8) | paletteData[i * 2 + 1];
      
      // Extract 3-bit color components (even values 0-14)
      const blue = (wordValue >> 8) & 0x0E;
      const green = (wordValue >> 4) & 0x0E;
      const red = wordValue & 0x0E;
      
      // Scale to 8-bit (multiply by 16 to get 0-224 range)
      out.push([red * 16, green * 16, blue * 16, 255]);
    }
    
    return out;
  }

  paletteFileInput.addEventListener('change', async ()=>{
    const buf = await readFile(paletteFileInput);
    if(!buf){ uploadedPalette = null; alert('No palette file selected'); return; }
    const pal = parsePaletteFile(buf);
    // ensure length 16
    while(pal.length < 16) pal.push([0,0,0,0]);
    uploadedPalette = pal;
    paletteSelect.value = 'custom';
    alert('Palette loaded (' + pal.length + ' entries). Now select Palette → Custom and Render.');
  });

  // decode single 8x8 tile from 32-byte buffer (standard MD 4bpp layout)
  function decodeTile(tileBytes){
    const pixels = new Uint8ClampedArray(8*8);
    if(tileBytes.length < 32) return pixels;
    for(let row=0; row<8; row++){
      const b0 = tileBytes[row*4 + 0];
      const b1 = tileBytes[row*4 + 1];
      const b2 = tileBytes[row*4 + 2];
      const b3 = tileBytes[row*4 + 3];
      for(let x=0;x<8;x++){
        const shift = 7-x;
        const bit0 = (b0>>shift)&1;
        const bit1 = (b1>>shift)&1;
        const bit2 = (b2>>shift)&1;
        const bit3 = (b3>>shift)&1;
        const val = (bit3<<3)|(bit2<<2)|(bit1<<1)|(bit0);
        pixels[row*8 + x] = val;
      }
    }
    return pixels;
  }

  function assembleStamp(stampsBuf, offset, stampSize){
    const tileBytes = 32;
    const tilesAcross = stampSize/8;
    const tilesDown = stampSize/8;
    const stampPixels = new Uint8ClampedArray(stampSize * stampSize);
    for(let tx=0; tx<tilesAcross; tx++){
      for(let ty=0; ty<tilesDown; ty++){
        const tileIndexWithinStamp = tx*tilesDown + ty; // column-major
        const tileOffset = offset + tileIndexWithinStamp * tileBytes;
        const tileSlice = new Uint8Array(stampsBuf, tileOffset, tileBytes);
        const tilePixels = decodeTile(tileSlice);
        for(let ry=0; ry<8; ry++){
          for(let rx=0; rx<8; rx++){
            const sx = tx*8 + rx;
            const sy = ty*8 + ry;
            stampPixels[sy*stampSize + sx] = tilePixels[ry*8 + rx];
          }
        }
      }
    }
    return stampPixels;
  }

  function drawStampToImageData(destImg, destW, destH, stampPixels, stampSize, dstX, dstY, palette, rotation, flipH){
    for(let sy=0; sy<stampSize; sy++){
      for(let sx=0; sx<stampSize; sx++){
        let x = sx, y = sy;
        if(rotation===1){ x = sy; y = stampSize - 1 - sx; }
        else if(rotation===2){ x = stampSize - 1 - sx; y = stampSize - 1 - sy; }
        else if(rotation===3){ x = stampSize - 1 - sy; y = sx; }
        if(flipH){ x = stampSize - 1 - x; }
        const palIdx = stampPixels[y*stampSize + x];
        const outX = dstX + sx;
        const outY = dstY + sy;
        if(outX < 0 || outY < 0 || outX >= destW || outY >= destH) continue;
        const oidx = (outY*destW + outX)*4;
        const color = palette[palIdx] || [0,0,0,0];
        destImg.data[oidx+0] = color[0];
        destImg.data[oidx+1] = color[1];
        destImg.data[oidx+2] = color[2];
        destImg.data[oidx+3] = color[3];
      }
    }
  }

  function parseMap(mapBuf){
    const dv = new DataView(mapBuf);
    const count = mapBuf.byteLength/2;
    const arr = [];
    for(let i=0;i<count;i++) arr.push(dv.getUint16(i*2, false));
    return arr;
  }

  async function renderFromBuffers(stampsBuf, mapBuf, stampSize){
    if(!stampsBuf || !mapBuf) return alert('Both files are required.');
    const entries = parseMap(mapBuf);
    let gridW = Math.sqrt(entries.length);
    if(!Number.isInteger(gridW)) gridW = Math.round(256/stampSize);
    const gridH = Math.ceil(entries.length/gridW);
    const mapWpx = gridW * stampSize;
    const mapHpx = gridH * stampSize;
    const outCanvas = document.createElement('canvas'); outCanvas.width = mapWpx; outCanvas.height = mapHpx;
    const outCtx = outCanvas.getContext('2d');
    const outImg = outCtx.createImageData(mapWpx, mapHpx);
    for(let i=0;i<outImg.data.length;i+=4){ outImg.data[i]=0; outImg.data[i+1]=0; outImg.data[i+2]=0; outImg.data[i+3]=0; }
    const palette = defaultPal(paletteSelect.value);
    const stampBlockSize = (stampSize===32) ? 512 : 128;
    for(let idx=0; idx < entries.length; idx++){
      const val = entries[idx];
      if(val === 0) continue;
      const flipH = !!(val & 0x8000);
      const rotBits = (val >> 13) & 0x3;
      const rotation = rotBits;
      const stampId = val & 0x07FF;
      const stampByteAddr = stampId * 0x80;
      if(stampByteAddr + stampBlockSize > stampsBuf.byteLength){ console.warn('stamp out of range', stampId, stampByteAddr); continue; }
      const stampPixels = assembleStamp(stampsBuf, stampByteAddr, stampSize);
      const mapX = idx % gridW;
      const mapY = Math.floor(idx / gridW);
      const dstX = mapX * stampSize;
      const dstY = mapY * stampSize;
      drawStampToImageData(outImg, mapWpx, mapHpx, stampPixels, stampSize, dstX, dstY, palette, rotation, flipH);
    }
    const scale = parseInt(scaleSelect.value || '2',10) || 1;
    canvas.width = mapWpx * scale; canvas.height = mapHpx * scale;
    outCtx.putImageData(outImg, 0, 0);
    ctx.imageSmoothingEnabled = false;
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(outCanvas, 0, 0, canvas.width, canvas.height);
  }

  renderBtn.addEventListener('click', async ()=>{
    const sBuf = await readFile(stampsFileInput);
    const mBuf = await readFile(mapFileInput);
    const stampSize = parseInt(stampSizeSelect.value,10);
    await renderFromBuffers(sBuf, mBuf, stampSize);
  });

  exportBtn.addEventListener('click', ()=>{
    const url = canvas.toDataURL();
    const a = document.createElement('a'); a.href = url; a.download = 'stampmap.png'; a.click();
  });

  // drag & drop convenience
  document.addEventListener('dragover', e=>{ e.preventDefault(); });
  document.addEventListener('drop', async (e)=>{
    e.preventDefault();
    const files = Array.from(e.dataTransfer.files || []);
    if(files.length===2){
      files.sort((a,b)=>b.size - a.size);
      stampsFileInput.files = new DataTransfer(); stampsFileInput.files = (()=>{ const dt=new DataTransfer(); dt.items.add(files[0]); return dt; })();
      mapFileInput.files = new DataTransfer(); mapFileInput.files = (()=>{ const dt=new DataTransfer(); dt.items.add(files[1]); return dt; })();
      renderBtn.click();
    }
  });

})();
  </script>
</body>
</html>
