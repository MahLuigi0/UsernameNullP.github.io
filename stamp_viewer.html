<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Cloud Stamp Viewer</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; padding: 18px; }
    .controls { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    label { font-size:13px; }
    canvas { border:1px solid #ccc; image-rendering: pixelated; margin-top:12px; }
    .note { color:#555; font-size:13px; }
    .preview { margin-top:12px; display:flex; gap:12px; align-items:center; }
    .small { width:128px; height:128px; border:1px dashed #ddd; }
  </style>
</head>
<body>
  <h2>Cloud Stamp Viewer (HTML + JS)</h2>
  <div class="controls">
    <label>Stamps file <input id="stampsFile" type="file" accept="*/*"></label>
    <label>Stamp map file <input id="mapFile" type="file" accept="*/*"></label>
    <label>Stamp size
      <select id="stampSize"><option value="32" selected>32×32</option><option value="16">16×16</option></select>
    </label>
    <label>Scale
      <select id="scale"><option>1</option><option selected>2</option><option>3</option><option>4</option><option>6</option></select>
    </label>
    <label>Palette
      <select id="palette">
        <option value="genesis">Genesis-style (default)</option>
        <option value="grayscale">Grayscale</option>
        <option value="cloud">Cloudy (blue)</option>
      </select>
    </label>
    <button id="renderBtn">Render</button>
    <button id="autosize">Fit canvas</button>
  </div>

  <div class="note">Instructions: select the two uncompressed files you were given and click <b>Render</b>. The app decodes 4bpp Mega Drive tiles (32 bytes per 8×8 tile), assembles stamps (column-major) and builds the stampmap. If the palette looks wrong you can swap presets or supply your own by editing the code.</div>

  <canvas id="view" width="256" height="256"></canvas>

  <script>
(function(){
  const stampsFileInput = document.getElementById('stampsFile');
  const mapFileInput = document.getElementById('mapFile');
  const stampSizeSelect = document.getElementById('stampSize');
  const renderBtn = document.getElementById('renderBtn');
  const scaleSelect = document.getElementById('scale');
  const paletteSelect = document.getElementById('palette');
  const autosizeBtn = document.getElementById('autosize');
  const canvas = document.getElementById('view');
  const ctx = canvas.getContext('2d');

  // helper to read file -> ArrayBuffer
  async function readFile(fileInput){
    const f = fileInput.files && fileInput.files[0];
    if(!f) return null;
    return await f.arrayBuffer();
  }

  function defaultPal(name){
    // returns 16 RGBA arrays
    if(name==='grayscale'){
      const p=[]; p.push([0,0,0,0]); for(let i=1;i<16;i++){ const v = Math.round(255*i/15); p.push([v,v,v,255]); } return p;
    }
    if(name==='cloud'){
      const p=[[0,0,0,0]];
      for(let i=1;i<16;i++){ const t = i/15; const r = Math.round(180 + 40*t); const g = Math.round(200 + 20*t); const b = Math.round(220 + 10*t); p.push([r,g,b,255]); }
      return p;
    }
    // genesis-like palette (approx)
    const base = [
      [0,0,0,0],[17,17,17,255],[45,45,45,255],[87,87,87,255],[141,141,170,255],[108,140,196,255],[84,152,208,255],[176,200,232,255],
      [120,100,80,255],[200,180,140,255],[240,200,180,255],[255,230,200,255],[120,200,120,255],[80,160,80,255],[40,120,40,255],[20,80,20,255]
    ];
    return base;
  }

  // decode single 8x8 tile from 32-byte buffer (standard MD 4bpp layout)
  function decodeTile(tileBytes){
    const pixels = new Uint8ClampedArray(8*8);
    if(tileBytes.length < 32) return pixels;
    for(let row=0; row<8; row++){
      const b0 = tileBytes[row*4 + 0];
      const b1 = tileBytes[row*4 + 1];
      const b2 = tileBytes[row*4 + 2];
      const b3 = tileBytes[row*4 + 3];
      for(let x=0;x<8;x++){
        const shift = 7-x;
        const bit0 = (b0>>shift)&1;
        const bit1 = (b1>>shift)&1;
        const bit2 = (b2>>shift)&1;
        const bit3 = (b3>>shift)&1;
        const val = (bit3<<3)|(bit2<<2)|(bit1<<1)|(bit0);
        pixels[row*8 + x] = val;
      }
    }
    return pixels;
  }

  // assemble a stamp (32 or 16) starting at offset bytes in stampsBuf
  function assembleStamp(stampsBuf, offset, stampSize){
    const tileBytes = 32; // 32 bytes per 8x8 tile
    const tilesAcross = stampSize/8;
    const tilesDown = stampSize/8;
    const stampPixels = new Uint8ClampedArray(stampSize * stampSize);
    const stampTileCount = tilesAcross * tilesDown;
    // tiles are stored column-major (vertical first) like MD sprites
    for(let tx=0; tx<tilesAcross; tx++){
      for(let ty=0; ty<tilesDown; ty++){
        const tileIndexWithinStamp = tx*tilesDown + ty; // column-major
        const tileOffset = offset + tileIndexWithinStamp * tileBytes;
        const tileSlice = new Uint8Array(stampsBuf, tileOffset, tileBytes);
        const tilePixels = decodeTile(tileSlice);
        // blit tilePixels into stampPixels at (tx*8, ty*8)
        for(let ry=0; ry<8; ry++){
          for(let rx=0; rx<8; rx++){
            const sx = tx*8 + rx;
            const sy = ty*8 + ry;
            stampPixels[sy*stampSize + sx] = tilePixels[ry*8 + rx];
          }
        }
      }
    }
    return stampPixels;
  }

  // draw a stamp (Uint8 pixels) into context with optional transforms
  function drawStampToImageData(destImg, destW, destH, stampPixels, stampSize, dstX, dstY, palette, rotation, flipH){
    // create a temporary ImageData for the stamp
    // We'll copy pixel-by-pixel respecting rotation/flip
    for(let sy=0; sy<stampSize; sy++){
      for(let sx=0; sx<stampSize; sx++){
        // compute source coordinates depending on rotation and flip
        let x = sx, y = sy;
        // apply rotation
        if(rotation===1){ // 90°
          x = sy; y = stampSize - 1 - sx;
        } else if(rotation===2){ // 180°
          x = stampSize - 1 - sx; y = stampSize - 1 - sy;
        } else if(rotation===3){ // 270°
          x = stampSize - 1 - sy; y = sx;
        }
        // apply horizontal flip
        if(flipH){ x = stampSize - 1 - x; }
        const palIdx = stampPixels[y*stampSize + x];
        const outX = dstX + sx;
        const outY = dstY + sy;
        if(outX < 0 || outY < 0 || outX >= destW || outY >= destH) continue;
        const oidx = (outY*destW + outX)*4;
        const color = palette[palIdx] || [0,0,0,0];
        destImg.data[oidx+0] = color[0];
        destImg.data[oidx+1] = color[1];
        destImg.data[oidx+2] = color[2];
        destImg.data[oidx+3] = color[3];
      }
    }
  }

  // parse map buffer (big-endian 16-bit entries) into array
  function parseMap(mapBuf){
    const dv = new DataView(mapBuf);
    const count = mapBuf.byteLength/2;
    const arr = [];
    for(let i=0;i<count;i++){
      arr.push(dv.getUint16(i*2, false)); // big-endian
    }
    return arr;
  }

  async function renderFromBuffers(stampsBuf, mapBuf, stampSize){
    if(!stampsBuf || !mapBuf) return alert('Both files are required.');
    // parse map
    const entries = parseMap(mapBuf);
    const nEntries = entries.length;
    // try to infer grid dimensions
    let gridW = Math.sqrt(nEntries);
    let gridH = gridW;
    if(!Number.isInteger(gridW)){
      // fallback: try width=256/stampSize
      gridW = Math.round(256/stampSize);
      gridH = Math.ceil(nEntries/gridW);
    }

    const mapWpx = gridW * stampSize;
    const mapHpx = gridH * stampSize;

    // create blank ImageData
    const outCanvas = document.createElement('canvas');
    outCanvas.width = mapWpx;
    outCanvas.height = mapHpx;
    const outCtx = outCanvas.getContext('2d');
    const outImg = outCtx.createImageData(mapWpx, mapHpx);
    // clear to transparent
    for(let i=0;i<outImg.data.length;i+=4){ outImg.data[i]=0; outImg.data[i+1]=0; outImg.data[i+2]=0; outImg.data[i+3]=0; }

    const palette = defaultPal(paletteSelect.value);

    const stampBlockSize = (stampSize===32) ? 512 : 128; // bytes

    // draw each map cell
    for(let idx=0; idx < entries.length; idx++){
      const val = entries[idx];
      if(val === 0) continue; // blank
      const flipH = !!(val & 0x8000);
      const rotBits = (val >> 13) & 0x3;
      const rotation = rotBits; // 0..3
      const stampId = val & 0x07FF;
      const stampByteAddr = stampId * 0x80; // address = id * $80
      // get stamp data slice - ensure in range
      if(stampByteAddr + stampBlockSize > stampsBuf.byteLength){
        console.warn('stamp out of range', stampId, stampByteAddr);
        continue;
      }
      const stampPixels = assembleStamp(stampsBuf, stampByteAddr, stampSize);
      const mapX = idx % gridW;
      const mapY = Math.floor(idx / gridW);
      const dstX = mapX * stampSize;
      const dstY = mapY * stampSize;
      drawStampToImageData(outImg, mapWpx, mapHpx, stampPixels, stampSize, dstX, dstY, palette, rotation, flipH);
    }

    // put image data onto visible canvas with selected scale
    const scale = parseInt(scaleSelect.value || '2',10) || 1;
    canvas.width = mapWpx * scale;
    canvas.height = mapHpx * scale;
    // put unscaled image to temp canvas
    outCtx.putImageData(outImg, 0, 0);
    // scale to visible canvas
    ctx.imageSmoothingEnabled = false;
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(outCanvas, 0, 0, canvas.width, canvas.height);
  }

  renderBtn.addEventListener('click', async ()=>{
    const sBuf = await readFile(stampsFileInput);
    const mBuf = await readFile(mapFileInput);
    const stampSize = parseInt(stampSizeSelect.value,10);
    await renderFromBuffers(sBuf, mBuf, stampSize);
  });

  autosizeBtn.addEventListener('click', ()=>{
    // scale canvas to fit window (simple)
    const scale = Math.max(1, Math.floor(Math.min((window.innerWidth-40)/canvas.width, (window.innerHeight-200)/canvas.height)));
    scaleSelect.value = String(scale);
  });

  // allow drag & drop onto whole document for convenience
  document.addEventListener('dragover', e=>{ e.preventDefault(); });
  document.addEventListener('drop', async (e)=>{
    e.preventDefault();
    const files = Array.from(e.dataTransfer.files || []);
    for(const f of files){
      if(f.name.toLowerCase().includes('stamp map')){ mapFileInput.files = new DataTransfer().files; }
    }
    // if exactly two files, try to assign
    if(files.length===2){
      // heuristics: larger is stamps
      files.sort((a,b)=>b.size - a.size);
      stampsFileInput.files = new DataTransfer(); stampsFileInput.files = (()=>{ const dt=new DataTransfer(); dt.items.add(files[0]); return dt; })();
      mapFileInput.files = new DataTransfer(); mapFileInput.files = (()=>{ const dt=new DataTransfer(); dt.items.add(files[1]); return dt; })();
      // auto render
      renderBtn.click();
    }
  });

  // small convenience: if user opens this inside a dev environment and the files are present at /mnt/data,
  // you cannot access them from a browser, so we rely on user file input.

})();
  </script>
</body>
</html>
